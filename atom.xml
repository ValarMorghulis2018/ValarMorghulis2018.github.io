<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>六姐的博客</title>
  
  <subtitle>Valar Morghulis</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-21T09:01:26.435Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Six Sister</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>推荐系统之召回</title>
    <link href="http://yoursite.com/2020/10/21/2020-10-21%20%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%8F%AC%E5%9B%9E/"/>
    <id>http://yoursite.com/2020/10/21/2020-10-21 推荐系统之召回/</id>
    <published>2020-10-21T08:57:10.000Z</published>
    <updated>2020-10-21T09:01:26.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="召回"><a href="#召回" class="headerlink" title="召回"></a>召回</h1><p>在推荐系统架构中召回层与排序层是推荐系统的核心算法层，而将推荐过程分成召回层与排序层主要是基于工程上的考虑，其中召回阶段负责将海量的候选集快速缩小为几万到几千的规模；而排序层则负责对缩小后的候选集进行精准排 序。所以在召回阶段往往会利用少量的特征和简单的模型对大规模的数据集进行快速的筛选，而在排序层一般会使用更多的特征和更加复杂的模型进行精准的排序。</p><hr><a id="more"></a><h3 id="召回层与排序层的特点"><a href="#召回层与排序层的特点" class="headerlink" title="召回层与排序层的特点"></a>召回层与排序层的特点</h3><ol><li>召回层：待计算的候选集合大、计算速度快、模型简单、特征较少，尽量让用户感兴趣的物品在这个阶段能够被快速召回，即保证相关物品的召回率</li><li>排序层：首要目标是得到精准的排序结果。需要处理的物品数量少，可以利用较多的特征，使用比较复杂的模型。</li></ol><p>在设计召回层时，需要权衡计算速度与召回率，工业上主流的召回方法是采用多个简单策略叠加的多路召回策略。</p><hr><h3 id="多路召回策略"><a href="#多路召回策略" class="headerlink" title="多路召回策略"></a>多路召回策略</h3><p>所谓的“多路召回”策略，就是指采用不同的策略、特征或简单模型，分别召回一部分候选集，然后把候选集混合在一起供<br>后续排序模型使用，可以明显的看出，“多路召回策略”是在“计算速度”和“召回率”之间进行权衡的结果。其中，各种简单<br>策略保证候选集的快速召回，从不同角度设计的策略保证召回率接近理想的状态，不至于影响排序效果。</p><p>如下图是多路召回的一个示意图，在多路召回中，每个策略之间毫不相关，所以一般可以写并发多线程同时进行，这样可以更加高效。</p><p>上图只是一个多路召回的例子，也就是说可以使用多种不同的策略来获取用户排序的候选商品集合，而具体使用哪些召回策略其实是与业务强相关的，针对不同的任务就会有对于该业务真实场景下需要考虑的召回规则。例如视频推荐，召回规则可以是“热门视频”、“导演召回”、“演员召回”、“最近上映“、”流行趋势“、”类型召回“等等。</p><h3 id="多路召回存在的问题"><a href="#多路召回存在的问题" class="headerlink" title="多路召回存在的问题"></a>多路召回存在的问题</h3><p>虽然多路召回权衡了计算速度和召回率的问题，可以使得用于排序的候选商品更加的丰富，但是实际的多路召回仍然存在一些问题。如上图所示，对于每一路召回都会从商品集合中拉回K个商品，这里的K是一个超参数，对于K的选择一般需要通过离线评估加线上的A/B测试来确定合理的K值。除此之外，对于不同的任务具体策略的选择也是人工基于经验的选择，选择的策略之间的信息是割裂的，无法总和考虑不同策略对一个物品的影响。</p><hr><h3 id="Embedding-召回"><a href="#Embedding-召回" class="headerlink" title="Embedding 召回"></a>Embedding 召回</h3><h5 id="Embedding是什么？"><a href="#Embedding是什么？" class="headerlink" title="Embedding是什么？"></a>Embedding是什么？</h5><p>Embedding其实是一种思想，主要目的是将稀疏的向量(如one-hot编码)表示转换成稠密的向量，下图直观的显示了one-hot编码和Embedding表示的区别于联系，即Embedding相当于是对one-hot做了平滑，而onehot相当于是对Embedding做了maxpooling。</p><p>目前主流的Embedding技术主要可以分为三大类</p><ol><li>text embedding</li><li>image embedding</li><li>graph embedding</li></ol><h5 id="常见的text-Embedding技术"><a href="#常见的text-Embedding技术" class="headerlink" title="常见的text Embedding技术"></a>常见的text Embedding技术</h5><ol><li>静态向量 Word2vec fasttext glove</li><li>动态向量 ELMO GPT BERT</li></ol><hr><h1 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h1><ol><li>为什么使用AUC<br>例如0.7的AUC，其含义可以大概理解为：给定一个正样本和一个负样本，在70%的情况下，模型对正样本的打分高于对负样本的打分。可以看出这个解释下，我们关心的只有正负样本之间的分数高低，而具体的分支则无关紧要【多高的AUC才算高】<br>参考文章 <a href="https://zhuanlan.zhihu.com/p/24217322" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24217322</a></li><li>如何使用Embedding做召回？<br>参考文章<a href="https://zhuanlan.zhihu.com/p/143763320" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/143763320</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;召回&quot;&gt;&lt;a href=&quot;#召回&quot; class=&quot;headerlink&quot; title=&quot;召回&quot;&gt;&lt;/a&gt;召回&lt;/h1&gt;&lt;p&gt;在推荐系统架构中召回层与排序层是推荐系统的核心算法层，而将推荐过程分成召回层与排序层主要是基于工程上的考虑，其中召回阶段负责将海量的候选集快速缩小为几万到几千的规模；而排序层则负责对缩小后的候选集进行精准排 序。所以在召回阶段往往会利用少量的特征和简单的模型对大规模的数据集进行快速的筛选，而在排序层一般会使用更多的特征和更加复杂的模型进行精准的排序。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="推荐系统" scheme="http://yoursite.com/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="推荐系统 Embedding 召回" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Embedding-%E5%8F%AC%E5%9B%9E/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/11/15/%E7%BB%9F%E8%AE%A1%E9%98%B3%E6%80%A7%E7%8E%87/"/>
    <id>http://yoursite.com/2019/11/15/统计阳性率/</id>
    <published>2019-11-15T04:54:49.929Z</published>
    <updated>2019-11-14T09:21:10.705Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import dash_core_components as dcc</span><br><span class="line"></span><br><span class="line"># 下拉列表框 Dropdown</span><br><span class="line">dcc.Dropdown(</span><br><span class="line">    options=[</span><br><span class="line">        &#123;&apos;label&apos;: &apos;New York City&apos;, &apos;value&apos;: &apos;NYC&apos;&#125;,</span><br><span class="line">        &#123;&apos;label&apos;: &apos;Montreal&apos;, &apos;value&apos;: &apos;MTL&apos;&#125;,</span><br><span class="line">        &#123;&apos;label&apos;: &apos;San Francisco&apos;, &apos;value&apos;: &apos;SF&apos;&#125;</span><br><span class="line">    ],</span><br><span class="line">    # 未选择任何值时显示的默认文本</span><br><span class="line">    placeholder=&quot;Select a city&quot;, </span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Leetcode【第十六题】最接近的三数之和</title>
    <link href="http://yoursite.com/2019/10/28/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E5%85%AD%E9%A2%98%E3%80%91%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/10/28/Leetcode【第十六题】最接近的三数之和/</id>
    <published>2019-10-28T10:43:10.000Z</published>
    <updated>2019-10-28T11:09:55.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-最接近的三数之和"><a href="#题目-最接近的三数之和" class="headerlink" title="题目 最接近的三数之和"></a>题目 最接近的三数之和</h1><blockquote><p>给定一个包括n 个整数的数组nums和一个目标值target。找出nums中的三个整数，使得它们的和与target最接近。返回这三个数的和。</p><p>假定每组输入只存在唯一答案。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>利用python函数特性 set 和 zip </p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote></blockquote><hr><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def threeSumClosest(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        size = len(nums)</span><br><span class="line">        diff = float(&apos;inf&apos;)</span><br><span class="line">        nums.sort()</span><br><span class="line">        for i in range(size - 2):</span><br><span class="line"></span><br><span class="line">            if i &gt; 0 and nums[i] == nums[i - 1]:</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">            left = i + 1</span><br><span class="line">            right = size - 1</span><br><span class="line">            while left &lt; right:</span><br><span class="line">                s = nums[i] + nums[left] + nums[right]</span><br><span class="line"></span><br><span class="line">                if abs(s - target) &lt; diff:</span><br><span class="line">                    diff = abs(s - target)</span><br><span class="line">                    res = s</span><br><span class="line"></span><br><span class="line">                if s &gt; target:</span><br><span class="line">                    right -= 1</span><br><span class="line">                elif s &lt; target:</span><br><span class="line">                    left += 1</span><br><span class="line">                else:</span><br><span class="line">                    return target</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-最接近的三数之和&quot;&gt;&lt;a href=&quot;#题目-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;题目 最接近的三数之和&quot;&gt;&lt;/a&gt;题目 最接近的三数之和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个包括n 个整数的数组nums和一个目标值target。找出nums中的三个整数，使得它们的和与target最接近。返回这三个数的和。&lt;/p&gt;
&lt;p&gt;假定每组输入只存在唯一答案。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十五题】三数之和</title>
    <link href="http://yoursite.com/2019/10/28/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E4%BA%94%E9%A2%98%E3%80%91%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/10/28/Leetcode【第十五题】三数之和/</id>
    <published>2019-10-28T08:37:12.000Z</published>
    <updated>2019-10-28T11:07:32.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-三数之和"><a href="#题目-三数之和" class="headerlink" title="题目 三数之和"></a>题目 三数之和</h1><blockquote><p>给定一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？</p><p>找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>利用双指针，注意边界和重复</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n2)</p><p>空间复杂度：O(n)</p></blockquote></blockquote><hr><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def threeSum(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if i &gt; 0 and nums[i] == nums[i - 1]:</span><br><span class="line">                continue</span><br><span class="line">            left = i + 1</span><br><span class="line">            right = len(nums) - 1</span><br><span class="line">            while left &lt; right:</span><br><span class="line">                cur_sum = nums[i] + nums[left] + nums[right]</span><br><span class="line">                if cur_sum == 0:</span><br><span class="line">                    tmp = [nums[i], nums[left], nums[right]]</span><br><span class="line">                    res.append(tmp)</span><br><span class="line">                    while left &lt; right and nums[left] == nums[left + 1]:</span><br><span class="line">                        left = left + 1</span><br><span class="line">                    while left &lt; right and nums[right] == nums[right - 1]:</span><br><span class="line">                        right = right - 1</span><br><span class="line">                    left = left + 1</span><br><span class="line">                    right = right - 1</span><br><span class="line">                elif cur_sum &gt; 0:</span><br><span class="line">                    right = right - 1</span><br><span class="line">                else:</span><br><span class="line">                    left = left + 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-三数之和&quot;&gt;&lt;a href=&quot;#题目-三数之和&quot; class=&quot;headerlink&quot; title=&quot;题目 三数之和&quot;&gt;&lt;/a&gt;题目 三数之和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？&lt;/p&gt;
&lt;p&gt;找出所有满足条件且不重复的三元组。&lt;/p&gt;
&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十四题】最长公共前缀</title>
    <link href="http://yoursite.com/2019/10/24/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E5%9B%9B%E9%A2%98%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://yoursite.com/2019/10/24/Leetcode【第十四题】最长公共前缀/</id>
    <published>2019-10-24T10:47:13.000Z</published>
    <updated>2019-10-28T08:35:23.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-最长公共前缀"><a href="#题目-最长公共前缀" class="headerlink" title="题目 最长公共前缀"></a>题目 最长公共前缀</h1><blockquote><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><blockquote><p>说明：所有输入只包含小写字母a-z</p></blockquote><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>利用python函数特性 set 和 zip </p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote></blockquote><hr><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = &quot;&quot;</span><br><span class="line">        for tmp in zip(*strs):</span><br><span class="line">            tmp_set = set(tmp)</span><br><span class="line">            if len(tmp_set) == 1:</span><br><span class="line">                res += tmp[0]</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-最长公共前缀&quot;&gt;&lt;a href=&quot;#题目-最长公共前缀&quot; class=&quot;headerlink&quot; title=&quot;题目 最长公共前缀&quot;&gt;&lt;/a&gt;题目 最长公共前缀&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode【第十三题】罗马数字转整数</title>
    <link href="http://yoursite.com/2019/10/24/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E4%B8%89%E9%A2%98%E3%80%91%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/24/Leetcode【第十三题】罗马数字转整数/</id>
    <published>2019-10-24T09:58:15.000Z</published>
    <updated>2019-10-24T10:43:42.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-整数转罗马数字"><a href="#题目-整数转罗马数字" class="headerlink" title="题目 整数转罗马数字"></a>题目 整数转罗马数字</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><blockquote><p>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：</p><p>I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。<br>X可以放在L(50) 和C(100) 的左边，来表示 40 和90。<br>C可以放在D(500) 和M(1000) 的左边，来表示400 和900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>此题可用哈希表列表储存几个特殊数值</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def romanToInt(self,s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dic = &#123;&quot;I&quot;: 1, &quot;V&quot;: 5, &quot;X&quot;: 10, &quot;L&quot;: 50, &quot;C&quot;: 100, &quot;D&quot;: 500, &quot;M&quot;: 1000&#125;</span><br><span class="line">        num = 0</span><br><span class="line">        for n, c in enumerate(s[:-1]):</span><br><span class="line">            if dic[c] &gt;= dic[s[n + 1]]:</span><br><span class="line">                num = num + dic[c]</span><br><span class="line">            else:</span><br><span class="line">                num = num - dic[c]</span><br><span class="line">        num = num + dic[s[-1]]</span><br><span class="line">        return num</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-整数转罗马数字&quot;&gt;&lt;a href=&quot;#题目-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;题目 整数转罗马数字&quot;&gt;&lt;/a&gt;题目 整数转罗马数字&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;字符          数值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I             1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;V             5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X             10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;L             50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C             100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D             500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M             1000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;p&gt;I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。&lt;br&gt;X可以放在L(50) 和C(100) 的左边，来表示 40 和90。&lt;br&gt;C可以放在D(500) 和M(1000) 的左边，来表示400 和900。&lt;br&gt;给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十二题】整数转罗马数字</title>
    <link href="http://yoursite.com/2019/10/23/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E4%BA%8C%E9%A2%98%E3%80%91%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2019/10/23/Leetcode【第十二题】整数转罗马数字/</id>
    <published>2019-10-23T11:25:01.000Z</published>
    <updated>2019-10-24T10:43:50.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-整数转罗马数字"><a href="#题目-整数转罗马数字" class="headerlink" title="题目 整数转罗马数字"></a>题目 整数转罗马数字</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><blockquote><p>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：</p><p>I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。<br>X可以放在L(50) 和C(100) 的左边，来表示 40 和90。<br>C可以放在D(500) 和M(1000) 的左边，来表示400 和900。<br>给定一个整数，将其转为罗马数字。输入确保在 1到 3999 的范围内。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>此题可用列表储存几个特殊数值，再用贪心算法求解</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intToRoman(self, num):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type num: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]</span><br><span class="line">        romans = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]</span><br><span class="line"></span><br><span class="line">        index = 0</span><br><span class="line">        res = &apos;&apos;</span><br><span class="line">        while index &lt; 13:</span><br><span class="line">            while num &gt;= nums[index]:</span><br><span class="line">                res = res + romans[index]</span><br><span class="line">                num = num - nums[index]</span><br><span class="line">            index += 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-整数转罗马数字&quot;&gt;&lt;a href=&quot;#题目-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;题目 整数转罗马数字&quot;&gt;&lt;/a&gt;题目 整数转罗马数字&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;字符          数值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I             1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;V             5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X             10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;L             50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C             100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D             500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M             1000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;p&gt;I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。&lt;br&gt;X可以放在L(50) 和C(100) 的左边，来表示 40 和90。&lt;br&gt;C可以放在D(500) 和M(1000) 的左边，来表示400 和900。&lt;br&gt;给定一个整数，将其转为罗马数字。输入确保在 1到 3999 的范围内。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="贪心算法" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十一题】盛最多水的容器</title>
    <link href="http://yoursite.com/2019/10/23/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E4%B8%80%E9%A2%98%E3%80%91%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/10/23/Leetcode【第十一题】盛最多水的容器/</id>
    <published>2019-10-23T10:25:01.000Z</published>
    <updated>2019-10-24T10:43:54.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-盛最多水的容器"><a href="#题目-盛最多水的容器" class="headerlink" title="题目 盛最多水的容器"></a>题目 盛最多水的容器</h1><blockquote><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai) 和 (i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且n的值至少为 2。</p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>由题易得：由线段形成的区域总是受到较短的那个线段以及两者间的距离决定。</p><p>移动指向较短线段的指针尽管造成了矩形宽度的减小，但却可能会有助于面积的增大。</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，遍历一遍整数字符串</p><p>空间复杂度：O(1)，存储容量为定值</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxArea(self, height):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type height: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        i, j, res = 0, len(height) - 1, 0</span><br><span class="line">        while i &lt; j:</span><br><span class="line">            min_height = min(height[i], height[j])</span><br><span class="line">            res = max(res, min_height * (j - i))</span><br><span class="line">            if height[i] &lt; height[j]:</span><br><span class="line">                i += 1</span><br><span class="line">            else:</span><br><span class="line">                j -= 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-盛最多水的容器&quot;&gt;&lt;a href=&quot;#题目-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;题目 盛最多水的容器&quot;&gt;&lt;/a&gt;题目 盛最多水的容器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai) 和 (i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;说明：你不能倾斜容器，且n的值至少为 2。&lt;/p&gt;
&lt;p&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="双指针法" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十题】正则表达式匹配</title>
    <link href="http://yoursite.com/2019/10/19/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E9%A2%98%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2019/10/19/Leetcode【第十题】正则表达式匹配/</id>
    <published>2019-10-19T10:23:43.000Z</published>
    <updated>2019-10-23T10:24:43.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-正则表达式匹配"><a href="#题目-正则表达式匹配" class="headerlink" title="题目 正则表达式匹配"></a>题目 正则表达式匹配</h1><blockquote><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘<em>‘ 的正则表达式匹配<br>‘.’ 匹配任意单个字符<br>‘</em>‘ 匹配零个或多个前面的那一个元素</p><p>所谓匹配，是要涵盖 整个字符串s的，而不是部分字符串。</p><p>说明:</p><pre><code>s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</code></pre></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>动态规划</p></blockquote><p><code>动态规划四要素</code></p><blockquote><p>状态</p><p>转移方程</p><p>初始化</p><p>结果</p></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-正则表达式匹配&quot;&gt;&lt;a href=&quot;#题目-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;题目 正则表达式匹配&quot;&gt;&lt;/a&gt;题目 正则表达式匹配&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘&lt;em&gt;‘ 的正则表达式匹配&lt;br&gt;‘.’ 匹配任意单个字符&lt;br&gt;‘&lt;/em&gt;‘ 匹配零个或多个前面的那一个元素&lt;/p&gt;
&lt;p&gt;所谓匹配，是要涵盖 整个字符串s的，而不是部分字符串。&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s 可能为空，且只包含从 a-z 的小写字母。

p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第九题】回文数</title>
    <link href="http://yoursite.com/2019/10/19/Leetcode%E3%80%90%E7%AC%AC%E4%B9%9D%E9%A2%98%E3%80%91%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/19/Leetcode【第九题】回文数/</id>
    <published>2019-10-19T08:23:43.000Z</published>
    <updated>2019-10-19T09:26:55.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-回文数"><a href="#题目-回文数" class="headerlink" title="题目 回文数"></a>题目 回文数</h1><blockquote><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>进阶:你能不将整数转为字符串来解决这个问题吗？</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>字符串解法：非负整数，反转，判断是否相等</p><p>非字符串解法：计算位数和余数，寻找对应关系</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(max(n,n/2))</p><p>空间复杂度：O(n)</p></blockquote></blockquote><p><code>pytho 除法运算符</code></p><blockquote><p>// 向下整除</p><p>% 取余</p></blockquote><hr><h4 id="代码1-字符串解法"><a href="#代码1-字符串解法" class="headerlink" title="代码1 字符串解法"></a>代码1 字符串解法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x: int) -&gt; bool:        </span><br><span class="line">        if str(x) == str(x)[::-1]:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure><h4 id="代码2-除法解法"><a href="#代码2-除法解法" class="headerlink" title="代码2 除法解法"></a>代码2 除法解法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x: int) -&gt; bool:        </span><br><span class="line">        if (x &lt; 0) or (x != 0 and x % 10 == 0):</span><br><span class="line">            return False</span><br><span class="line">        cmp_num = 0</span><br><span class="line">        while x &gt; cmp_num:</span><br><span class="line">            cmp_num = cmp_num * 10 + x % 10</span><br><span class="line">            x //= 10</span><br><span class="line">        return x == cmp_num or x == cmp_num // 10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-回文数&quot;&gt;&lt;a href=&quot;#题目-回文数&quot; class=&quot;headerlink&quot; title=&quot;题目 回文数&quot;&gt;&lt;/a&gt;题目 回文数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;p&gt;进阶:你能不将整数转为字符串来解决这个问题吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="回文数" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第八题】字符串转换整数（atoi）</title>
    <link href="http://yoursite.com/2019/10/19/Leetcode%E3%80%90%E7%AC%AC%E5%85%AB%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%EF%BC%88atoi%EF%BC%89/"/>
    <id>http://yoursite.com/2019/10/19/Leetcode【第八题】字符串转换整数（atoi）/</id>
    <published>2019-10-19T08:09:07.000Z</published>
    <updated>2019-10-19T08:09:38.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-字符串转换整数"><a href="#题目-字符串转换整数" class="headerlink" title="题目 字符串转换整数"></a>题目 字符串转换整数</h1><blockquote><p>请你来实现一个atoi函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为[−231, 231− 1]。如果数值超过这个范围，请返回INT_MAX (231− 1) 或INT_MIN (−231) 。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。</span><br><span class="line">因此无法执行有效的转换。</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>考验循环中附加条件的位置关系 ==这题比较恶心，想尝试简化流程，但很难。==</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，遍历一遍整数字符串</p><p>空间复杂度：O(n)，总长最长为整数字符串长度</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def myAtoi(self, str):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type str: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        raw_str = str</span><br><span class="line">        </span><br><span class="line">        # 可靠字符集</span><br><span class="line">        valid_set = </span><br><span class="line">        &#123;</span><br><span class="line">            &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, </span><br><span class="line">            &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;,</span><br><span class="line">            &apos;+&apos;, &apos;-&apos;, &apos; &apos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        # 数字字符集</span><br><span class="line">        num_set = </span><br><span class="line">        &#123;</span><br><span class="line">        &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, </span><br><span class="line">        &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        # 正负字符集</span><br><span class="line">        sign_set = &#123;&apos;+&apos;, &apos;-&apos;&#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        k = 0  # 当前位置</span><br><span class="line">        m = 0  # 正负计数符</span><br><span class="line">        p = 0  # 空格位置符</span><br><span class="line">        n = 0  # 正负位置符</span><br><span class="line">        i = 0  # 位数</span><br><span class="line"></span><br><span class="line">        tmp_str = &apos;&apos;</span><br><span class="line"></span><br><span class="line">        if len(raw_str) == 0:</span><br><span class="line">        # 【可能性】 空字符串</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        if raw_str[0] not in valid_set:</span><br><span class="line">        # 【可能性】 非可靠字符串</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        for s in raw_str:</span><br><span class="line">        </span><br><span class="line">            if s in sign_set:</span><br><span class="line">                if i &gt; 0:</span><br><span class="line">                    break</span><br><span class="line">                m = m + 1</span><br><span class="line">                n = k</span><br><span class="line">                # 【可能性】 字符串含超过1个正负号</span><br><span class="line">                if m &gt; 1:</span><br><span class="line">                    return 0</span><br><span class="line">                    </span><br><span class="line">            if s == &apos; &apos;:</span><br><span class="line">                if i &gt; 0:</span><br><span class="line">                    break</span><br><span class="line">                p = k</span><br><span class="line"></span><br><span class="line">            if s in num_set:</span><br><span class="line">                # 【可能性】 正负号后跟空格</span><br><span class="line">                if p &gt; n and m &gt; 0:</span><br><span class="line">                    return 0</span><br><span class="line">                i = i + 1</span><br><span class="line">                tmp_str = tmp_str + s</span><br><span class="line"></span><br><span class="line">            if s not in valid_set:</span><br><span class="line">                k = k + 1</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            k = k + 1</span><br><span class="line"></span><br><span class="line">        if i == 0:</span><br><span class="line">            return 0</span><br><span class="line">        else:</span><br><span class="line">            if m &gt; 0:</span><br><span class="line">                tmp_str = raw_str[n] + tmp_str</span><br><span class="line"></span><br><span class="line">        covert_int = int(tmp_str)</span><br><span class="line"></span><br><span class="line">        # 越界判断</span><br><span class="line">        if covert_int &gt;= 2**31 - 1:</span><br><span class="line">            return 2**31 - 1</span><br><span class="line">        if covert_int &lt;= (-2**31):</span><br><span class="line">            return (-2**31)</span><br><span class="line"></span><br><span class="line">        return covert_int</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-字符串转换整数&quot;&gt;&lt;a href=&quot;#题目-字符串转换整数&quot; class=&quot;headerlink&quot; title=&quot;题目 字符串转换整数&quot;&gt;&lt;/a&gt;题目 字符串转换整数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;请你来实现一个atoi函数，使其能将字符串转换成整数。&lt;/p&gt;
&lt;p&gt;首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。&lt;/p&gt;
&lt;p&gt;当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。&lt;/p&gt;
&lt;p&gt;该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。&lt;/p&gt;
&lt;p&gt;注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。&lt;/p&gt;
&lt;p&gt;在任何情况下，若函数不能进行有效的转换时，请返回 0。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为[−231, 231− 1]。如果数值超过这个范围，请返回INT_MAX (231− 1) 或INT_MIN (−231) 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="编程基础" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第七题】整数反转</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%B8%83%E9%A2%98%E3%80%91%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第七题】整数反转/</id>
    <published>2019-10-16T09:44:07.000Z</published>
    <updated>2019-10-16T09:47:51.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-整数反转"><a href="#题目-整数反转" class="headerlink" title="题目 整数反转"></a>题目 整数反转</h1><blockquote><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>注意:<br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为[−231, 231− 1]。</p><p>请根据这个假设，如果反转后整数溢出那么就返回 0。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>考验对基本函数的熟悉程度</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，遍历一遍整数字符串</p><p>空间复杂度：O(n)，总长为整数字符串长度</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def reverse(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        list_str_x = list(str(abs(x)))</span><br><span class="line"></span><br><span class="line">        res = int(&apos;&apos;.join(list_str_x[::-1]))</span><br><span class="line">        if res &lt; -  2147483648 or res &gt; 2147483647 :</span><br><span class="line">            res = 0</span><br><span class="line">        return res if x &gt; 0 else - res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-整数反转&quot;&gt;&lt;a href=&quot;#题目-整数反转&quot; class=&quot;headerlink&quot; title=&quot;题目 整数反转&quot;&gt;&lt;/a&gt;题目 整数反转&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为[−231, 231− 1]。&lt;/p&gt;
&lt;p&gt;请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode【第六题】Z字形变换</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E5%85%AD%E9%A2%98%E3%80%91z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第六题】z字形变换/</id>
    <published>2019-10-16T09:42:07.000Z</published>
    <updated>2019-10-16T09:47:30.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-Z字形变换"><a href="#题目-Z字形变换" class="headerlink" title="题目 Z字形变换"></a>题目 Z字形变换</h1><blockquote><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “LEETCODEISHIRING”行数为 3 时，排列如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><blockquote><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>找到Z字的转折点规律是关键</p><p>标记示例字符串各字符所在行数 ==’LDREOEIIECIHNTSG’==</p><p>L E E T C O D E I S H I R I N G</p><p>1 2 3 2 1 2 3 2 1 2 3 2 1 2 3 2</p><p>L E E T C O D E I S H I R I N G</p><p>1 2 3 4 3 2 1 2 3 4 3 2 1 2 3 4</p><p>易得规律：转折点在[1,numRows]两端反复</p><p>定义一个计数器，记录当前行数与给定行数间的关系，当行数为1或等于给定行数时，取相反数</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，遍历一遍字符串</p><p>空间复杂度：O(n)，需要对应的列表存储，总长为字符串长度</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def convert(self, s, numRows):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :type numRows: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 行数小于2，直接返回</span><br><span class="line">        if numRows &lt; 2:</span><br><span class="line">            return s</span><br><span class="line">        </span><br><span class="line">        # 以字符串构建行列表</span><br><span class="line">        res = [&apos;&apos; for i in range(numRows)]</span><br><span class="line"></span><br><span class="line">        spot = - 1 # 转折点</span><br><span class="line">        n = 1 # 计数器</span><br><span class="line">        for str_ in s:</span><br><span class="line">            res[n - 1] = res[n - 1] + str_</span><br><span class="line">            if n == 1 or n == numRows:</span><br><span class="line">                spot = - spot</span><br><span class="line">            n = n + spot</span><br><span class="line"></span><br><span class="line">        return &apos;&apos;.join(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-Z字形变换&quot;&gt;&lt;a href=&quot;#题目-Z字形变换&quot; class=&quot;headerlink&quot; title=&quot;题目 Z字形变换&quot;&gt;&lt;/a&gt;题目 Z字形变换&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;br&gt;比如输入字符串为 “LEETCODEISHIRING”行数为 3 时，排列如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;L   C   I   R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E T O E S I I G&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E   D   H   N&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode【第五题】最长回文子串</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%BA%94%E9%A2%98%E3%80%91%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第五题】最长回文子串/</id>
    <published>2019-10-16T06:12:07.000Z</published>
    <updated>2019-10-16T06:13:02.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-最长回文子串"><a href="#题目-最长回文子串" class="headerlink" title="题目 最长回文子串"></a>题目 最长回文子串</h1><blockquote><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>在有序数组中，寻找一个索引i ，使得<br>索引左边的数小于等于索引右边的数</p><p>当两个数组的元素之和为奇数时，size 左 = size 右 + 1</p><p>当两个数组的元素之和为偶数时，size 左 = size 右</p><p>考虑边界线附近的划分</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(n²)，需要二维数对存储状态</p></blockquote></blockquote><p><code>and 和 or 的短路原则</code></p><blockquote><p>对于 and 来说：</p><p>如果第一个条件的结论为假，那么 and 前后两个条件组成的表达式计算结果一定为假，后面的条件计算机不会进行计算</p><p>对于 or 来说：</p><p>如果第一个条件的结论为真，那么 or 前后两个条件组成的表达式计算结果一定为真，后面的条件计算机不会进行计算</p></blockquote><hr><p><code>动态规划 dynamic programming</code></p><blockquote><p>1、定义 “状态”；</p><p>2、找到 “状态转移方程”。</p></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def longestPalindrome(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        size = len(s)</span><br><span class="line">        if size &lt;= 1:</span><br><span class="line">            return s</span><br><span class="line">        # 二维 dp 问题</span><br><span class="line">        dp = [[False for _ in range(size)] for _ in range(size)]</span><br><span class="line">    </span><br><span class="line">        longest_l = 1</span><br><span class="line">        res = s[0]</span><br><span class="line">    </span><br><span class="line">        # 左边界一定要比右边界小，因此右边界从 1 开始</span><br><span class="line">        for right_ in range(1, size):</span><br><span class="line">            for left_ in range(right_):</span><br><span class="line">                # 状态转移方程：如果头尾字符相等并且中间也是回文</span><br><span class="line">                if s[left_] == s[right_] and (right_ - left_ &lt;= 2 or dp[left_ + 1][right_ - 1]):</span><br><span class="line">                    # 更新状态</span><br><span class="line">                    dp[left_][right_] = True</span><br><span class="line">                    cur_len = right_ - left_ + 1</span><br><span class="line">                    if cur_len &gt; longest_l:</span><br><span class="line">                        longest_l = cur_len</span><br><span class="line">                        res = s[left_:right_ + 1]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-最长回文子串&quot;&gt;&lt;a href=&quot;#题目-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;题目 最长回文子串&quot;&gt;&lt;/a&gt;题目 最长回文子串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="回文" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第四题】寻找两个有序数组的中位数</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E5%9B%9B%E9%A2%98%E3%80%91%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第四题】寻找两个有序数组的中位数/</id>
    <published>2019-10-16T06:10:07.000Z</published>
    <updated>2019-10-16T06:14:27.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-寻找两个有序数组的中位数"><a href="#题目-寻找两个有序数组的中位数" class="headerlink" title="题目 寻找两个有序数组的中位数"></a>题目 寻找两个有序数组的中位数</h1><blockquote><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>在有序数组中，寻找一个索引i ，使得<br>索引左边的数小于等于索引右边的数</p><p>当两个数组的元素之和为奇数时，size 左 = size 右 + 1</p><p>当两个数组的元素之和为偶数时，size 左 = size 右</p><p>考虑边界线附近的划分</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(log(min(m,n)))</p><p>查找区间为[0,m]，该区间的长度在每次循环后都会减少一半。所以，我们只需要执行 log(m) 次循环。</p><p>由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log(m))。<br>由于 m≤n，所以时间复杂度是 O(log({min}(m,n)))。</p><p>空间复杂度：O(1)，<br>只需存储几个局部变量</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def findMedianSortedArrays(A, B):</span><br><span class="line">    m, n = len(A), len(B)</span><br><span class="line">    if m &gt; n:</span><br><span class="line">        A, B, m, n = B, A, n, m</span><br><span class="line">    if n == 0:</span><br><span class="line">        raise ValueError</span><br><span class="line"></span><br><span class="line">    imin, imax, half_len = 0, m, (m + n + 1) / 2</span><br><span class="line">    while imin &lt;= imax:</span><br><span class="line">        i = (imin + imax) / 2</span><br><span class="line">        j = half_len - i</span><br><span class="line">        if i &lt; m and B[j-1] &gt; A[i]:</span><br><span class="line">            imin = i + 1</span><br><span class="line">        elif i &gt; 0 and A[i-1] &gt; B[j]:</span><br><span class="line">            imax = i - 1</span><br><span class="line">        else:</span><br><span class="line">            if i == 0: max_of_left = B[j-1]</span><br><span class="line">            elif j == 0: max_of_left = A[i-1]</span><br><span class="line">            else: max_of_left = max(A[i-1], B[j-1])</span><br><span class="line"></span><br><span class="line">            if (m + n) % 2 == 1:</span><br><span class="line">                return max_of_left</span><br><span class="line"></span><br><span class="line">            if i == m: min_of_right = B[j]</span><br><span class="line">            elif j == n: min_of_right = A[i]</span><br><span class="line">            else: min_of_right = min(A[i], B[j])</span><br><span class="line"></span><br><span class="line">            return (max_of_left + min_of_right) / 2.0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-寻找两个有序数组的中位数&quot;&gt;&lt;a href=&quot;#题目-寻找两个有序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;题目 寻找两个有序数组的中位数&quot;&gt;&lt;/a&gt;题目 寻找两个有序数组的中位数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;/p&gt;
&lt;p&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;/p&gt;
&lt;p&gt;你可以假设 nums1 和 nums2 不会同时为空。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="二分法" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第三题】无重复字符串的最长子串</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%B8%89%E9%A2%98%E3%80%91%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第三题】无重复字符串的最长子串/</id>
    <published>2019-10-16T06:09:07.000Z</published>
    <updated>2019-10-16T06:22:58.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-无重复字符串的最长子串"><a href="#题目-无重复字符串的最长子串" class="headerlink" title="题目 无重复字符串的最长子串"></a>题目 无重复字符串的最长子串</h1><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是&quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot;是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>滑动窗口是数组/字符串问题中常用的抽象概念。</p><p>窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j)向右滑动 1 个元素，则它将变为 [i+1, j+1)（左闭，右开）。</p><p>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j)（最初 j = i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n) or O(2n)</p><p>空间复杂度：O(min(m,n))，<br>滑动窗口的大小为所求子串的最大长度 k。k取决于 m,n 两者的最小值</p></blockquote></blockquote><hr><h4 id="代码-1-有添加删除动作的滑动窗口"><a href="#代码-1-有添加删除动作的滑动窗口" class="headerlink" title="代码 1 有添加删除动作的滑动窗口"></a>代码 1 有添加删除动作的滑动窗口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 缺点是真实增删数据，内存消耗严重</span><br><span class="line">class Solution(object):</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 如果字符串s为空，返回0</span><br><span class="line">        if not s:</span><br><span class="line">            return 0</span><br><span class="line">    </span><br><span class="line">        Sliding_window = []</span><br><span class="line">        max_len = 0</span><br><span class="line">        cur_len = 0</span><br><span class="line">    </span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            char_val = s[i]</span><br><span class="line">            # 如果该值不在窗口中</span><br><span class="line">            if char_val not in Sliding_window:</span><br><span class="line">                Sliding_window.append(char_val)</span><br><span class="line">                cur_len = cur_len + 1</span><br><span class="line">    </span><br><span class="line">            # 如果该值在窗口中已存在</span><br><span class="line">            else:</span><br><span class="line">                index = Sliding_window.index(char_val)</span><br><span class="line">                # 移除该位置及之前的所有字符</span><br><span class="line">                Sliding_window = Sliding_window[index+1:]</span><br><span class="line">                Sliding_window.append(char_val)</span><br><span class="line">                cur_len = len(Sliding_window)</span><br><span class="line">    </span><br><span class="line">            if cur_len &gt; max_len:</span><br><span class="line">                max_len = cur_len</span><br><span class="line">    </span><br><span class="line">        return max_len</span><br></pre></td></tr></table></figure><hr><h4 id="代码-2-模拟左右指针的滑动窗口"><a href="#代码-2-模拟左右指针的滑动窗口" class="headerlink" title="代码 2 模拟左右指针的滑动窗口"></a>代码 2 模拟左右指针的滑动窗口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 优点是不直接操作窗口</span><br><span class="line">class Solution(object):</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 如果字符串s为空，返回0</span><br><span class="line">        if not s:</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        Sliding_window = s</span><br><span class="line">        max_len = 0      # 滑动窗口数组</span><br><span class="line">        left, right = 0, 0  # 双指针</span><br><span class="line">    </span><br><span class="line">        for i, char_val in enumerate(Sliding_window):</span><br><span class="line">            # 如果该值不在窗口中</span><br><span class="line">            if char_val not in Sliding_window[left:right]:</span><br><span class="line">                right = right + 1</span><br><span class="line">            # 如果该值在窗口中已存在，移除该位置及之前的所有字符</span><br><span class="line">            else:</span><br><span class="line">                # 左指针 右指针 右移一位</span><br><span class="line">                left = left + Sliding_window[left:right].index(char_val) + 1</span><br><span class="line">                right = right + 1</span><br><span class="line">    </span><br><span class="line">            # 更新最大长度</span><br><span class="line">            max_len = max(right - left, max_len)</span><br><span class="line"></span><br><span class="line">        return max_len if max_len != 0 else len(Sliding_window)</span><br></pre></td></tr></table></figure><hr><h4 id="代码-3-哈希表"><a href="#代码-3-哈希表" class="headerlink" title="代码 3 ==哈希表=="></a>代码 3 ==哈希表==</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def lengthOfLongestSubstring(self, s):</span><br><span class="line"></span><br><span class="line">    # 可抛弃字符串的索引尾值 - 字符串索引值，该索引值以及之前的字符都属于重复字符串中的一部分，不再在计算中涉及</span><br><span class="line">    ignore_str_index_end = -1</span><br><span class="line">    dic = &#123;&#125;  # 任意字符最后出现在索引的位置 - &#123;字符: 字符索引值&#125;</span><br><span class="line">    max_len = 0  # 最长字符串长度</span><br><span class="line"></span><br><span class="line">    for i, char_val in enumerate(s):</span><br><span class="line">        # 如果字典中已经存在字符char_val，则字符char_val重复</span><br><span class="line">        # 先更新可抛弃字符串的索引尾值为字符char_val上一次的索引值</span><br><span class="line">        if char_val in dic and dic[char_val] &gt; ignore_str_index_end:</span><br><span class="line">            ignore_str_index_end = dic[char_val]</span><br><span class="line">            # 再更新字符char_val的索引值</span><br><span class="line">            dic[char_val] = i</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            # 更新字符最近的索引位置</span><br><span class="line">            dic[char_val] = i</span><br><span class="line">            # 更新最大长度</span><br><span class="line">            max_len = max(dic[char_val] - ignore_str_index_end, max_len)</span><br><span class="line"></span><br><span class="line">    return max_len</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-无重复字符串的最长子串&quot;&gt;&lt;a href=&quot;#题目-无重复字符串的最长子串&quot; class=&quot;headerlink&quot; title=&quot;题目 无重复字符串的最长子串&quot;&gt;&lt;/a&gt;题目 无重复字符串的最长子串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第二题】两数相加</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%BA%8C%E9%A2%98%E3%80%91%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第二题】两数相加/</id>
    <published>2019-10-16T05:51:44.000Z</published>
    <updated>2019-10-16T06:12:41.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-两数相加"><a href="#题目-两数相加" class="headerlink" title="题目 两数相加"></a>题目 两数相加</h1><blockquote><p>给出两个非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0开头。</p></blockquote><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表l1和l2的表头开始相加。由于每位数字都应当处于0…9的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为2，并将进位carry = 1带入下一次迭代。进位carry必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(max(m,n))，<br>假设m和n分别为l1,l2的长度，数位相加，最多运算max(m,n),所以时间复杂度为 O(max(m,n))。</p><p>空间复杂度：O(max(m,n))，<br>新列表的长度最多为max(m,n)+1。</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line">class ListNode(object):</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def addTwoNumbers(self, n, m):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type n: ListNode</span><br><span class="line">        :type m: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 两次循环将列表转换为数值 step 1</span><br><span class="line">        carry_bit = 1   # 进位符 carry bit</span><br><span class="line">        num_l1 = 0</span><br><span class="line">        while n:</span><br><span class="line">            num_l1 = num_l1 + n.val * carry_bit</span><br><span class="line">            carry_bit = carry_bit * 10</span><br><span class="line">            n = n.next</span><br><span class="line"></span><br><span class="line">        # 两次循环将列表转换为数值 step 2</span><br><span class="line">        carry_bit = 1</span><br><span class="line">        num_l2 = 0</span><br><span class="line">        while m:</span><br><span class="line">            num_l2 = num_l2 + m.val * carry_bit</span><br><span class="line">            carry_bit = carry_bit * 10</span><br><span class="line">            m = m.next</span><br><span class="line"></span><br><span class="line">        # 转换成字符串</span><br><span class="line">        str_num = str(num_l1 + num_l2)</span><br><span class="line">        # 倒序排列</span><br><span class="line">        str_num = str_num[::-1]</span><br><span class="line">        res = list_result = ListNode(0)</span><br><span class="line"></span><br><span class="line">        for num in str_num:</span><br><span class="line">            list_result.next = ListNode(int(num))</span><br><span class="line">            list_result = list_result.next</span><br><span class="line">        return res.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-两数相加&quot;&gt;&lt;a href=&quot;#题目-两数相加&quot; class=&quot;headerlink&quot; title=&quot;题目 两数相加&quot;&gt;&lt;/a&gt;题目 两数相加&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给出两个非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。&lt;/p&gt;
&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;
&lt;p&gt;您可以假设除了数字 0 之外，这两个数都不会以 0开头。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="计算符号" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E7%AC%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第一题】两数之和</title>
    <link href="http://yoursite.com/2019/10/14/Leetcode%E3%80%90%E7%AC%AC%E4%B8%80%E9%A2%98%E3%80%91%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/10/14/Leetcode【第一题】两数之和/</id>
    <published>2019-10-14T06:23:07.000Z</published>
    <updated>2019-10-16T06:12:32.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-两数之和"><a href="#题目-两数之和" class="headerlink" title="题目 两数之和"></a>题目 两数之和</h1><blockquote><p>给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p></blockquote><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><hr><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><blockquote><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？==哈希表==。</p><p>通过==以空间换取速度==的方式，我们可以将查找时间从 ==O(n)降低到 O(1)==。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。</p><p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，<br>我们把包含有 n个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。</p><p>空间复杂度：O(n)，<br>所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。</p></blockquote></blockquote><hr><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        for ind,num in enumerate(nums): # 第一次迭代创建哈希表</span><br><span class="line">            hashmap[num] = ind</span><br><span class="line">        for i,num in enumerate(nums):</span><br><span class="line">            j = hashmap.get(target - num)</span><br><span class="line">            if j is not None and i!=j:</span><br><span class="line">                return [i,j]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-两数之和&quot;&gt;&lt;a href=&quot;#题目-两数之和&quot; class=&quot;headerlink&quot; title=&quot;题目 两数之和&quot;&gt;&lt;/a&gt;题目 两数之和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。&lt;br&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
