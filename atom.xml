<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>六姐的博客</title>
  
  <subtitle>Valar Morghulis</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-16T06:13:02.753Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Six Sister</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode【第五题】最长回文子串</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%BA%94%E9%A2%98%E3%80%91%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第五题】最长回文子串/</id>
    <published>2019-10-16T06:12:07.000Z</published>
    <updated>2019-10-16T06:13:02.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-最长回文子串"><a href="#题目-最长回文子串" class="headerlink" title="题目 最长回文子串"></a>题目 最长回文子串</h1><blockquote><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>在有序数组中，寻找一个索引i ，使得<br>索引左边的数小于等于索引右边的数</p><p>当两个数组的元素之和为奇数时，size 左 = size 右 + 1</p><p>当两个数组的元素之和为偶数时，size 左 = size 右</p><p>考虑边界线附近的划分</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(n²)，需要二维数对存储状态</p></blockquote></blockquote><p><code>and 和 or 的短路原则</code></p><blockquote><p>对于 and 来说：</p><p>如果第一个条件的结论为假，那么 and 前后两个条件组成的表达式计算结果一定为假，后面的条件计算机不会进行计算</p><p>对于 or 来说：</p><p>如果第一个条件的结论为真，那么 or 前后两个条件组成的表达式计算结果一定为真，后面的条件计算机不会进行计算</p></blockquote><hr><p><code>动态规划 dynamic programming</code></p><blockquote><p>1、定义 “状态”；</p><p>2、找到 “状态转移方程”。</p></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def longestPalindrome(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        size = len(s)</span><br><span class="line">        if size &lt;= 1:</span><br><span class="line">            return s</span><br><span class="line">        # 二维 dp 问题</span><br><span class="line">        dp = [[False for _ in range(size)] for _ in range(size)]</span><br><span class="line">    </span><br><span class="line">        longest_l = 1</span><br><span class="line">        res = s[0]</span><br><span class="line">    </span><br><span class="line">        # 左边界一定要比右边界小，因此右边界从 1 开始</span><br><span class="line">        for right_ in range(1, size):</span><br><span class="line">            for left_ in range(right_):</span><br><span class="line">                # 状态转移方程：如果头尾字符相等并且中间也是回文</span><br><span class="line">                if s[left_] == s[right_] and (right_ - left_ &lt;= 2 or dp[left_ + 1][right_ - 1]):</span><br><span class="line">                    # 更新状态</span><br><span class="line">                    dp[left_][right_] = True</span><br><span class="line">                    cur_len = right_ - left_ + 1</span><br><span class="line">                    if cur_len &gt; longest_l:</span><br><span class="line">                        longest_l = cur_len</span><br><span class="line">                        res = s[left_:right_ + 1]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-最长回文子串&quot;&gt;&lt;a href=&quot;#题目-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;题目 最长回文子串&quot;&gt;&lt;/a&gt;题目 最长回文子串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="回文" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第四题】寻找两个有序数组的中位数</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E5%9B%9B%E9%A2%98%E3%80%91%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第四题】寻找两个有序数组的中位数/</id>
    <published>2019-10-16T06:10:07.000Z</published>
    <updated>2019-10-16T06:14:27.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-寻找两个有序数组的中位数"><a href="#题目-寻找两个有序数组的中位数" class="headerlink" title="题目 寻找两个有序数组的中位数"></a>题目 寻找两个有序数组的中位数</h1><blockquote><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>在有序数组中，寻找一个索引i ，使得<br>索引左边的数小于等于索引右边的数</p><p>当两个数组的元素之和为奇数时，size 左 = size 右 + 1</p><p>当两个数组的元素之和为偶数时，size 左 = size 右</p><p>考虑边界线附近的划分</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(log(min(m,n)))</p><p>查找区间为[0,m]，该区间的长度在每次循环后都会减少一半。所以，我们只需要执行 log(m) 次循环。</p><p>由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log(m))。<br>由于 m≤n，所以时间复杂度是 O(log({min}(m,n)))。</p><p>空间复杂度：O(1)，<br>只需存储几个局部变量</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def findMedianSortedArrays(A, B):</span><br><span class="line">    m, n = len(A), len(B)</span><br><span class="line">    if m &gt; n:</span><br><span class="line">        A, B, m, n = B, A, n, m</span><br><span class="line">    if n == 0:</span><br><span class="line">        raise ValueError</span><br><span class="line"></span><br><span class="line">    imin, imax, half_len = 0, m, (m + n + 1) / 2</span><br><span class="line">    while imin &lt;= imax:</span><br><span class="line">        i = (imin + imax) / 2</span><br><span class="line">        j = half_len - i</span><br><span class="line">        if i &lt; m and B[j-1] &gt; A[i]:</span><br><span class="line">            imin = i + 1</span><br><span class="line">        elif i &gt; 0 and A[i-1] &gt; B[j]:</span><br><span class="line">            imax = i - 1</span><br><span class="line">        else:</span><br><span class="line">            if i == 0: max_of_left = B[j-1]</span><br><span class="line">            elif j == 0: max_of_left = A[i-1]</span><br><span class="line">            else: max_of_left = max(A[i-1], B[j-1])</span><br><span class="line"></span><br><span class="line">            if (m + n) % 2 == 1:</span><br><span class="line">                return max_of_left</span><br><span class="line"></span><br><span class="line">            if i == m: min_of_right = B[j]</span><br><span class="line">            elif j == n: min_of_right = A[i]</span><br><span class="line">            else: min_of_right = min(A[i], B[j])</span><br><span class="line"></span><br><span class="line">            return (max_of_left + min_of_right) / 2.0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-寻找两个有序数组的中位数&quot;&gt;&lt;a href=&quot;#题目-寻找两个有序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;题目 寻找两个有序数组的中位数&quot;&gt;&lt;/a&gt;题目 寻找两个有序数组的中位数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;/p&gt;
&lt;p&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;/p&gt;
&lt;p&gt;你可以假设 nums1 和 nums2 不会同时为空。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="二分法" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第三题】无重复字符串的最长子串</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%B8%89%E9%A2%98%E3%80%91%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第三题】无重复字符串的最长子串/</id>
    <published>2019-10-16T06:09:07.000Z</published>
    <updated>2019-10-16T06:22:58.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-无重复字符串的最长子串"><a href="#题目-无重复字符串的最长子串" class="headerlink" title="题目 无重复字符串的最长子串"></a>题目 无重复字符串的最长子串</h1><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是&quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot;是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>滑动窗口是数组/字符串问题中常用的抽象概念。</p><p>窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j)向右滑动 1 个元素，则它将变为 [i+1, j+1)（左闭，右开）。</p><p>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j)（最初 j = i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n) or O(2n)</p><p>空间复杂度：O(min(m,n))，<br>滑动窗口的大小为所求子串的最大长度 k。k取决于 m,n 两者的最小值</p></blockquote></blockquote><hr><h4 id="代码-1-有添加删除动作的滑动窗口"><a href="#代码-1-有添加删除动作的滑动窗口" class="headerlink" title="代码 1 有添加删除动作的滑动窗口"></a>代码 1 有添加删除动作的滑动窗口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 缺点是真实增删数据，内存消耗严重</span><br><span class="line">class Solution(object):</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 如果字符串s为空，返回0</span><br><span class="line">        if not s:</span><br><span class="line">            return 0</span><br><span class="line">    </span><br><span class="line">        Sliding_window = []</span><br><span class="line">        max_len = 0</span><br><span class="line">        cur_len = 0</span><br><span class="line">    </span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            char_val = s[i]</span><br><span class="line">            # 如果该值不在窗口中</span><br><span class="line">            if char_val not in Sliding_window:</span><br><span class="line">                Sliding_window.append(char_val)</span><br><span class="line">                cur_len = cur_len + 1</span><br><span class="line">    </span><br><span class="line">            # 如果该值在窗口中已存在</span><br><span class="line">            else:</span><br><span class="line">                index = Sliding_window.index(char_val)</span><br><span class="line">                # 移除该位置及之前的所有字符</span><br><span class="line">                Sliding_window = Sliding_window[index+1:]</span><br><span class="line">                Sliding_window.append(char_val)</span><br><span class="line">                cur_len = len(Sliding_window)</span><br><span class="line">    </span><br><span class="line">            if cur_len &gt; max_len:</span><br><span class="line">                max_len = cur_len</span><br><span class="line">    </span><br><span class="line">        return max_len</span><br></pre></td></tr></table></figure><hr><h4 id="代码-2-模拟左右指针的滑动窗口"><a href="#代码-2-模拟左右指针的滑动窗口" class="headerlink" title="代码 2 模拟左右指针的滑动窗口"></a>代码 2 模拟左右指针的滑动窗口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 优点是不直接操作窗口</span><br><span class="line">class Solution(object):</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 如果字符串s为空，返回0</span><br><span class="line">        if not s:</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        Sliding_window = s</span><br><span class="line">        max_len = 0      # 滑动窗口数组</span><br><span class="line">        left, right = 0, 0  # 双指针</span><br><span class="line">    </span><br><span class="line">        for i, char_val in enumerate(Sliding_window):</span><br><span class="line">            # 如果该值不在窗口中</span><br><span class="line">            if char_val not in Sliding_window[left:right]:</span><br><span class="line">                right = right + 1</span><br><span class="line">            # 如果该值在窗口中已存在，移除该位置及之前的所有字符</span><br><span class="line">            else:</span><br><span class="line">                # 左指针 右指针 右移一位</span><br><span class="line">                left = left + Sliding_window[left:right].index(char_val) + 1</span><br><span class="line">                right = right + 1</span><br><span class="line">    </span><br><span class="line">            # 更新最大长度</span><br><span class="line">            max_len = max(right - left, max_len)</span><br><span class="line"></span><br><span class="line">        return max_len if max_len != 0 else len(Sliding_window)</span><br></pre></td></tr></table></figure><hr><h4 id="代码-3-哈希表"><a href="#代码-3-哈希表" class="headerlink" title="代码 3 ==哈希表=="></a>代码 3 ==哈希表==</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def lengthOfLongestSubstring(self, s):</span><br><span class="line"></span><br><span class="line">    # 可抛弃字符串的索引尾值 - 字符串索引值，该索引值以及之前的字符都属于重复字符串中的一部分，不再在计算中涉及</span><br><span class="line">    ignore_str_index_end = -1</span><br><span class="line">    dic = &#123;&#125;  # 任意字符最后出现在索引的位置 - &#123;字符: 字符索引值&#125;</span><br><span class="line">    max_len = 0  # 最长字符串长度</span><br><span class="line"></span><br><span class="line">    for i, char_val in enumerate(s):</span><br><span class="line">        # 如果字典中已经存在字符char_val，则字符char_val重复</span><br><span class="line">        # 先更新可抛弃字符串的索引尾值为字符char_val上一次的索引值</span><br><span class="line">        if char_val in dic and dic[char_val] &gt; ignore_str_index_end:</span><br><span class="line">            ignore_str_index_end = dic[char_val]</span><br><span class="line">            # 再更新字符char_val的索引值</span><br><span class="line">            dic[char_val] = i</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            # 更新字符最近的索引位置</span><br><span class="line">            dic[char_val] = i</span><br><span class="line">            # 更新最大长度</span><br><span class="line">            max_len = max(dic[char_val] - ignore_str_index_end, max_len)</span><br><span class="line"></span><br><span class="line">    return max_len</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-无重复字符串的最长子串&quot;&gt;&lt;a href=&quot;#题目-无重复字符串的最长子串&quot; class=&quot;headerlink&quot; title=&quot;题目 无重复字符串的最长子串&quot;&gt;&lt;/a&gt;题目 无重复字符串的最长子串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第二题】两数相加</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%BA%8C%E9%A2%98%E3%80%91%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第二题】两数相加/</id>
    <published>2019-10-16T05:51:44.000Z</published>
    <updated>2019-10-16T06:12:41.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-两数相加"><a href="#题目-两数相加" class="headerlink" title="题目 两数相加"></a>题目 两数相加</h1><blockquote><p>给出两个非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0开头。</p></blockquote><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表l1和l2的表头开始相加。由于每位数字都应当处于0…9的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为2，并将进位carry = 1带入下一次迭代。进位carry必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(max(m,n))，<br>假设m和n分别为l1,l2的长度，数位相加，最多运算max(m,n),所以时间复杂度为 O(max(m,n))。</p><p>空间复杂度：O(max(m,n))，<br>新列表的长度最多为max(m,n)+1。</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line">class ListNode(object):</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def addTwoNumbers(self, n, m):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type n: ListNode</span><br><span class="line">        :type m: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 两次循环将列表转换为数值 step 1</span><br><span class="line">        carry_bit = 1   # 进位符 carry bit</span><br><span class="line">        num_l1 = 0</span><br><span class="line">        while n:</span><br><span class="line">            num_l1 = num_l1 + n.val * carry_bit</span><br><span class="line">            carry_bit = carry_bit * 10</span><br><span class="line">            n = n.next</span><br><span class="line"></span><br><span class="line">        # 两次循环将列表转换为数值 step 2</span><br><span class="line">        carry_bit = 1</span><br><span class="line">        num_l2 = 0</span><br><span class="line">        while m:</span><br><span class="line">            num_l2 = num_l2 + m.val * carry_bit</span><br><span class="line">            carry_bit = carry_bit * 10</span><br><span class="line">            m = m.next</span><br><span class="line"></span><br><span class="line">        # 转换成字符串</span><br><span class="line">        str_num = str(num_l1 + num_l2)</span><br><span class="line">        # 倒序排列</span><br><span class="line">        str_num = str_num[::-1]</span><br><span class="line">        res = list_result = ListNode(0)</span><br><span class="line"></span><br><span class="line">        for num in str_num:</span><br><span class="line">            list_result.next = ListNode(int(num))</span><br><span class="line">            list_result = list_result.next</span><br><span class="line">        return res.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-两数相加&quot;&gt;&lt;a href=&quot;#题目-两数相加&quot; class=&quot;headerlink&quot; title=&quot;题目 两数相加&quot;&gt;&lt;/a&gt;题目 两数相加&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给出两个非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。&lt;/p&gt;
&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;
&lt;p&gt;您可以假设除了数字 0 之外，这两个数都不会以 0开头。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="计算符号" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E7%AC%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第一题】两数之和</title>
    <link href="http://yoursite.com/2019/10/14/Leetcode%E3%80%90%E7%AC%AC%E4%B8%80%E9%A2%98%E3%80%91%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/10/14/Leetcode【第一题】两数之和/</id>
    <published>2019-10-14T06:23:07.000Z</published>
    <updated>2019-10-16T06:12:32.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-两数之和"><a href="#题目-两数之和" class="headerlink" title="题目 两数之和"></a>题目 两数之和</h1><blockquote><p>给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p></blockquote><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><hr><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><blockquote><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？==哈希表==。</p><p>通过==以空间换取速度==的方式，我们可以将查找时间从 ==O(n)降低到 O(1)==。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。</p><p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，<br>我们把包含有 n个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。</p><p>空间复杂度：O(n)，<br>所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。</p></blockquote></blockquote><hr><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        for ind,num in enumerate(nums): # 第一次迭代创建哈希表</span><br><span class="line">            hashmap[num] = ind</span><br><span class="line">        for i,num in enumerate(nums):</span><br><span class="line">            j = hashmap.get(target - num)</span><br><span class="line">            if j is not None and i!=j:</span><br><span class="line">                return [i,j]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-两数之和&quot;&gt;&lt;a href=&quot;#题目-两数之和&quot; class=&quot;headerlink&quot; title=&quot;题目 两数之和&quot;&gt;&lt;/a&gt;题目 两数之和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。&lt;br&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
