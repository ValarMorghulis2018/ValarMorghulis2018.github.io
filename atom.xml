<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>六姐的博客</title>
  
  <subtitle>Valar Morghulis</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-25T14:33:59.027Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Six Sister</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020-10-25-推荐系统之矩阵分解和FM</title>
    <link href="http://yoursite.com/2020/10/25/2020-10-25-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E5%92%8CFM/"/>
    <id>http://yoursite.com/2020/10/25/2020-10-25-推荐系统之矩阵分解和FM/</id>
    <published>2020-10-25T14:50:46.000Z</published>
    <updated>2020-10-25T14:33:59.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h1><p>协同过滤算法的特点就是完全没有利用到物品本身或者是用户自身的属性， 仅仅利用了用户与物品的交互信息就可以实现推荐，是一个可解释性很强， 非常直观的模型， 但是也存在一些问题， 第一个就是处理稀疏矩阵的能力比较弱， 所以为 了使得协同过滤更好处理稀疏矩阵问题， 增强泛化能力， 从协同过滤中衍生出矩阵分解模型(Matrix Factorization,MF)或者叫隐语义模型, 两者差不多说的一个意思， 就是在协同过滤共现矩阵的基础上， 使用更稠密的隐向量表示用户和物品，挖掘用户和物品的隐含兴趣和隐含特征， 在一定程度上弥补协同过滤模型处理稀疏矩阵能力不足的问题。</p><h3 id="隐语义模型"><a href="#隐语义模型" class="headerlink" title="隐语义模型"></a>隐语义模型</h3><p>隐语义模型最早在文本领域被提出，用于找到文本的隐含语义。在2006年， 被用于推荐中， 它的核心思想是通过隐含特 征（latentfactor）联系用户兴趣和物品（item）， 基于用户的行为找出潜在的主题和分类， 然后对item进行自动聚 类，划分到不同类别/主题(用户的兴趣)。</p><p>如果我们知道了用户A和用户B两个用户在豆瓣的读书列表， 从他们的阅读列表可以看出，用户A的兴趣涉及侦探小说、科普图书以及一些计算机技术书， 而用户B的兴趣比较集中在数学和机器学习方面。 那么如何给A和B推荐图书呢？<br>先说说协同过滤算法， 这样好对比不同：</p><ol><li>对于UserCF，首先需要找到和他们看了同样书的其他用户（兴趣相似的用户），然后给他们推荐那些用户喜欢的其他书。</li><li>对于ItemCF，需要给他们推荐和他们已经看的书相似的书，比如作者B看了很多关于数据挖掘的书，可以给他推荐机器学习或者模式识别方面的书。<br>而如果是隐语义模型的话， 它会先通过一些角度把用户兴趣和这些书归一下类， 当来了用户之后， 首先得到他的兴趣分类， 然后从这个分类中挑选他可能喜欢的书籍。</li></ol><h3 id="FM算法"><a href="#FM算法" class="headerlink" title="FM算法"></a>FM算法</h3><p>FM的学习算法主要包括，随机梯度下降（sgd）、交替最小二乘（als）、马尔可夫链蒙特卡罗（mcmc）。</p><p>当你有一个多维度稀疏矩阵，通过矩阵因式分解你能够将用户-项目矩阵（user-item matrix）重构成低评分结构（low-rank structure），并且你能够通过两个低评分（ low-rank）矩阵相乘得出这个矩阵，其中矩阵的行包含潜在向量。<br>通过低评价矩阵乘积尽可能调整这个矩阵近似原始矩阵，以填充原始矩阵中缺失的项。<br>优点：更好解决可扩展性和稀疏问题而被广泛用于推荐系统<br>缺点：矩阵分解时间复杂度高，可采用梯度下降的方法减少计算复杂度</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;矩阵分解&quot;&gt;&lt;a href=&quot;#矩阵分解&quot; class=&quot;headerlink&quot; title=&quot;矩阵分解&quot;&gt;&lt;/a&gt;矩阵分解&lt;/h1&gt;&lt;p&gt;协同过滤算法的特点就是完全没有利用到物品本身或者是用户自身的属性， 仅仅利用了用户与物品的交互信息就可以实现推荐，是一个可解
      
    
    </summary>
    
      <category term="Numpy" scheme="http://yoursite.com/categories/Numpy/"/>
    
    
  </entry>
  
  <entry>
    <title>2020-10-23-Numpy之数组操作</title>
    <link href="http://yoursite.com/2020/10/25/2020-10-23-Numpy%E4%B9%8B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/10/25/2020-10-23-Numpy之数组操作/</id>
    <published>2020-10-25T11:50:46.000Z</published>
    <updated>2020-10-25T13:14:07.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="更改形状"><a href="#更改形状" class="headerlink" title="更改形状"></a>更改形状</h1><p>在对数组进行操作时，为了满足格式和计算要求通常会改变其形状。<br>numpy.shape</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">print(x.shape)</span><br><span class="line">x.shape = [<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><p>numpy.flat<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>],</span><br><span class="line">             [<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],</span><br><span class="line">             [<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>],</span><br><span class="line">             [<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>],</span><br><span class="line">             [<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>]])</span><br><span class="line">y = x.flat</span><br><span class="line">print(y)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y:</span><br><span class="line">print(i, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure></p><p>numpy.flatten()<br>a. order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’k’ – 元素在内存中的出现顺序。(简记)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>],</span><br><span class="line">             [<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],</span><br><span class="line">             [<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>],</span><br><span class="line">             [<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>],</span><br><span class="line">             [<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line">y = x.flatten(order = <span class="string">'F'</span>)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment">#  [11 16 21 26 31 12 17 22 27 32 13 18 23 28 33 14 19 24 29 34 15 20 25 30  35]</span></span><br></pre></td></tr></table></figure></p><p>numpy.reshape(a, newshape[, order=’C’])<br>在不更改数据的情况下为数组赋予新的形状。<br>reshape()  函数</p><ul><li>当参数 newshape = [rows,-1] 时，将根据行数自动确定列数。</li><li>当参数 newshape = -1 时，表示将数组降为一维<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arrange(<span class="number">12</span>)</span><br><span class="line">y = np.reshape(x, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># [[ 0 1 2 3] </span></span><br><span class="line"><span class="comment">#  [ 4 5 6 7] </span></span><br><span class="line"><span class="comment">#  [ 8 9 10 11]]</span></span><br><span class="line">y = np.reshape(x, [<span class="number">3</span>, <span class="number">-1</span>])</span><br><span class="line"><span class="comment"># [[ 0 1 2 3] </span></span><br><span class="line"><span class="comment">#  [ 4 5 6 7] </span></span><br><span class="line"><span class="comment">#  [ 8 9 10 11]]</span></span><br><span class="line">y = np.reshape(x, <span class="number">-1</span>)</span><br><span class="line"><span class="comment"># [11 9 1 1 10 3 0 6 1 4 11 3]</span></span><br></pre></td></tr></table></figure></li></ul><p>numpy.transpose(a, axes=None)<br>numpy.T</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.random.rand(<span class="number">5</span>, <span class="number">5</span>) * <span class="number">10</span></span><br><span class="line">x = np.around(x, <span class="number">2</span>)</span><br><span class="line">y = x.T = np.transpose(x)</span><br></pre></td></tr></table></figure><h3 id="更改维度"><a href="#更改维度" class="headerlink" title="更改维度"></a>更改维度</h3><p>numpy.newaxis = None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">print(x.shape)</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line">y = x[np.newaxis, :]</span><br><span class="line">print(y.shape)</span><br><span class="line"><span class="comment"># (1, 8)</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [1 2 9 4 5 6 7 8]</span></span><br><span class="line"></span><br><span class="line">y = x[:, np.newaxis]</span><br><span class="line">print(y.shape)</span><br><span class="line"><span class="comment"># (8, 1)</span></span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [[1] </span></span><br><span class="line"><span class="comment">#  [2] </span></span><br><span class="line"><span class="comment">#  [9] </span></span><br><span class="line"><span class="comment">#  [4] </span></span><br><span class="line"><span class="comment">#  [5] </span></span><br><span class="line"><span class="comment">#  [6] </span></span><br><span class="line"><span class="comment">#  [7] </span></span><br><span class="line"><span class="comment">#  [8]]</span></span><br></pre></td></tr></table></figure><p>numpy.squeeze(a, axis=None)<br>从数组的形状中删除单维度条目，即把shape中为1的维度去掉。<br>在机器学习和深度学习中，通常算法的结果是可以表示向量的数组（即包含两对或以上的方括号形式[[]]），如果直接利用这个数组进行画图可能显示界面为空（见后面的示例）。我们可以利用 squeeze() 函数将表示向量的数组转换为秩为1的数组，这样利用 matplotlib 库函数画图时，就可以正常的显示结果了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">print(x.shape) <span class="comment"># (10,)</span></span><br><span class="line">x = x[np.newaxis, :]</span><br><span class="line">print(x.shape) <span class="comment"># (1, 10)</span></span><br><span class="line">y = np.squeeze(x)</span><br><span class="line">print(y.shape) <span class="comment"># (10,)</span></span><br></pre></td></tr></table></figure></p><h3 id="数组组合"><a href="#数组组合" class="headerlink" title="数组组合"></a>数组组合</h3><p>如果要将两份数据组合到一起，就需要拼接操作。<br>numpy.stack()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">y = np.array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">z = np.stack([x, y])</span><br><span class="line">print(z.shape) <span class="comment"># (2, 3)</span></span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [[ 1 2 3] </span></span><br><span class="line"><span class="comment">#  [ 7 8 9]]</span></span><br><span class="line"></span><br><span class="line">z = np.stack([x, y], axis=<span class="number">1</span>)</span><br><span class="line">print(z.shape) <span class="comment"># (3, 2)</span></span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [[1 7] </span></span><br><span class="line"><span class="comment">#  [2 8] </span></span><br><span class="line"><span class="comment">#  [3 9]]</span></span><br></pre></td></tr></table></figure></p><p>numpy.concatenate()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">y = np.array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">z = np.concatenate([x, y])</span><br><span class="line">print(z) <span class="comment"># [1 2 3 7 8 9]</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).reshape(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">y = np.array([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]).reshape(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">z = np.concatenate([x, y])</span><br><span class="line">print(z)</span><br><span class="line"><span class="comment"># [[ 1 2 3] </span></span><br><span class="line"><span class="comment">#  [ 7 8 9]]</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;更改形状&quot;&gt;&lt;a href=&quot;#更改形状&quot; class=&quot;headerlink&quot; title=&quot;更改形状&quot;&gt;&lt;/a&gt;更改形状&lt;/h1&gt;&lt;p&gt;在对数组进行操作时，为了满足格式和计算要求通常会改变其形状。&lt;br&gt;numpy.shape&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
      <category term="Numpy" scheme="http://yoursite.com/categories/Numpy/"/>
    
    
  </entry>
  
  <entry>
    <title>2020-10-23 Numpy之索引</title>
    <link href="http://yoursite.com/2020/10/23/2020-10-23-Numpy%E4%B9%8B%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2020/10/23/2020-10-23-Numpy之索引/</id>
    <published>2020-10-23T04:25:58.000Z</published>
    <updated>2020-10-23T07:46:30.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h1><h3 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a>整数索引</h3><p>【例】要获取数组的单个元素，指定元素的索引即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">print(x[<span class="number">2</span>]) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>],</span><br><span class="line">             [<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],</span><br><span class="line">             [<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>],</span><br><span class="line">             [<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>],</span><br><span class="line">             [<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line">print(x[<span class="number">2</span>]) <span class="comment"># [21 22 23 24 25]</span></span><br><span class="line">print(x[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment"># 22</span></span><br><span class="line">print(x[<span class="number">2</span>, <span class="number">1</span>]) <span class="comment"># 22</span></span><br></pre></td></tr></table></figure><hr><h3 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h3><p>切片操作是指抽取数组的一部分元素生成新数组。对 python 列表进行切片操作得到的数组是原数组的副本，而对 Numpy 数据进行切片操作得到的数组则是指向相同缓冲区的视图。<br>如果想抽取（或查看）数组的一部分，必须使用切片语法，也就是，把几个用冒号（start:stop:step ）隔开的数字置于方括号内。<br>为了更好地理解切片语法，还应该了解不明确指明起始和结束位置的情况。如省去第一个数字，numpy 会认为第一个数字是0；如省去第二个数字，numpy 则会认为第二个数字是数组的最大索引值；如省去最后一个数字，它将会被理解为1，也就是抽取所有元素而不再考虑间隔。<br>【例】对一维数组切片<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">print(x[<span class="number">0</span>:<span class="number">2</span>]) <span class="comment"># [1 2]</span></span><br><span class="line">print(x[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]) <span class="comment"># [2 4]</span></span><br><span class="line">print(x[<span class="number">2</span>:]) <span class="comment"># [3 4 5 6 7 8]</span></span><br></pre></td></tr></table></figure></p><p>【例】对二维数组切片<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>],</span><br><span class="line">             [<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],</span><br><span class="line">             [<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>],</span><br><span class="line">             [<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>],</span><br><span class="line">             [<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>]])</span><br><span class="line">print(x[<span class="number">2</span>:])  <span class="comment"># [[21 22 23 24 25] [26 27 28 29 30] [31 32 33 34 35]]</span></span><br><span class="line">print(x[<span class="number">2</span>,:]) <span class="comment"># [[11 12 13 14 15] [16 17 18 19 20]]</span></span><br><span class="line">print(x[:<span class="number">2</span>])  <span class="comment"># [21 22 23 24 25]</span></span><br><span class="line">print(x[:,<span class="number">2</span>]) <span class="comment"># [13 18 23 28 33]</span></span><br></pre></td></tr></table></figure></p><p>通过对每个以逗号分隔的维度执行单独的切片，你可以对多维数组进行切片。因此，对于二维数组，我们的第一片定义了行的切片，第二片定义了列的切片。</p><h3 id="dots索引"><a href="#dots索引" class="headerlink" title="dots索引"></a>dots索引</h3><p>NumPy 允许使用<code>...</code> 表示足够多的冒号来构建完整的索引列表。</p><h3 id="整数数组索引"><a href="#整数数组索引" class="headerlink" title="整数数组索引"></a>整数数组索引</h3><p>【例】方括号内传入多个索引值，可以同时选择多个元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">r = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">print(x[r]) <span class="comment"># [1 2 3]</span></span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>],</span><br><span class="line">             [<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],</span><br><span class="line">             [<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>],</span><br><span class="line">             [<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>],</span><br><span class="line">             [<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>]])</span><br><span class="line">r = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">c = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">y = x[r, c]</span><br><span class="line">print(y) <span class="comment"># [13 19 25]</span></span><br></pre></td></tr></table></figure></p><h3 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h3><p>我们可以通过一个布尔数组来索引目标数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">y = x &gt; <span class="number">5</span></span><br><span class="line">print(y) <span class="comment"># [False False False False False  True  True  True]</span></span><br><span class="line">print(x[x &gt; <span class="number">5</span>]) <span class="comment"># [6 7 8]</span></span><br><span class="line"></span><br><span class="line">x = np.array([np.nan, <span class="number">1</span>, <span class="number">2</span>, np.nan, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">y = np.logical_not(np.isnan(x))</span><br><span class="line">print(x[y]) <span class="comment"># [1. 2. 3. 4. 5.]</span></span><br></pre></td></tr></table></figure><h3 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h3><p>除了for循环，Numpy还提供另外一种更为优雅的遍历方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>],</span><br><span class="line">             [<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>],</span><br><span class="line">             [<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>],</span><br><span class="line">             [<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>],</span><br><span class="line">             [<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line">y = np.apply_along_axis(np.sum, <span class="number">0</span>, x)</span><br><span class="line">print(y) <span class="comment"># [105 110 115 120 125]</span></span><br><span class="line"></span><br><span class="line">y = np.apply_along_axis(np.sum, <span class="number">1</span>, x)</span><br><span class="line">print(y) <span class="comment"># [ 65  90 115 140 165]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;索引与切片&quot;&gt;&lt;a href=&quot;#索引与切片&quot; class=&quot;headerlink&quot; title=&quot;索引与切片&quot;&gt;&lt;/a&gt;索引与切片&lt;/h1&gt;&lt;h3 id=&quot;整数索引&quot;&gt;&lt;a href=&quot;#整数索引&quot; class=&quot;headerlink&quot; title=&quot;整数索引&quot;
      
    
    </summary>
    
      <category term="Numpy" scheme="http://yoursite.com/categories/Numpy/"/>
    
    
  </entry>
  
  <entry>
    <title>推荐系统之协同过滤</title>
    <link href="http://yoursite.com/2020/10/21/2020-10-21%20%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/"/>
    <id>http://yoursite.com/2020/10/21/2020-10-21 推荐系统之协同过滤/</id>
    <published>2020-10-21T10:00:10.000Z</published>
    <updated>2020-10-22T13:12:15.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协同过滤"><a href="#协同过滤" class="headerlink" title="协同过滤"></a>协同过滤</h1><p>协同过滤（Collaborative Filtering）推荐算法是最经典、最常用的推荐算法。<br>所谓协同过滤， 基本思想是根据用户之前的喜好以及其他兴趣相近的用户的选择来给用户推荐物品(基于对用户历史行为数据的挖掘发现用户的喜好偏向， 并预测用户可能喜好的产品进行推荐)，一般是仅仅基于用户的行为数据（评价、购 买、下载等），而不依赖于项的任何附加信息（物品自身特征）或者用户的任何附加信息（年龄， 性别等）。目前应用比较广泛的协同过滤算法是基于邻域的方法， 而这种方法主要有下面两种算法：</p><ol><li>基于用户的协同过滤算法(UserCF):给用户推荐和他兴趣相似的其他用户喜欢的产品</li><li>基于物品的协同过滤算法(ItemCF): 给用户推荐和他之前喜欢的物品相似的物品<br>不管是UserCF还是ItemCF算法， 非常重要的步骤之一就是计算用户和用户或者物品和物品之间的相似度， 所以下面先整理常用的相似性度量方法， 然后再对每个算法的具体细节进行展开。</li></ol><hr><a id="more"></a><h3 id="相似性度量方法"><a href="#相似性度量方法" class="headerlink" title="相似性度量方法"></a>相似性度量方法</h3><ol><li><p>杰卡德（Jaccard）相似系数：这个是衡量两个集合的相似度一种指标。两个用户 u 和 v<br>$$<br>sim_{uv}=\frac{|N(u) \cap N(v)|}{|N(u) \cup N(v)|}<br>$$<br>由于杰卡德相似系数一般无法反应具体用户的评分信息，所以常用来评估用户是否会对某商品进行打分， 而不 是预估用户会对某商品打多少分。</p></li><li><p>余弦相似度：</p></li></ol><p>余弦相似度衡量了两个向量的夹角，夹角越小越相似。首先从集合的角度描述余弦相似度，相比于Jaccard公式来说就 是分母有差异，不是两个用户交互商品的并集的数量，而是两个用户分别交互的商品数量的乘积，公式如下：<br>$$<br>sim_{uv}=\frac{|N(u)| \cap |N(v)|}{\sqrt{|N(u)|\cdot|N(v)|}}<br>$$<br>从向量的角度进行描述，令矩阵 A 为用户-商品交互矩阵(因为是TopN推荐并不需要用户对物品的评分，只需要知道用户对商品是否有交互就行)，即矩阵的每一行表示一个用户对所有商品的交互情况，有交互的商品值为1没有交互的商品值为0，矩阵的列表示所有商品。若用户和商品数量分别为 m,n 的话，交互矩阵 A 就是一个 m 行 n 列的矩阵。此时用户的相似度可以表示为(其中 u⋅v 指的是向量点积)：<br>$$<br>sim_{uv} = cos(u,v) =\frac{u\cdot v}{|u|\cdot |v|}<br>$$<br> 上述用户-商品交互矩阵在现实情况下是非常的稀疏了，为了避免存储这么大的稀疏矩阵，在计算用户相似度的时候 一般会采用集合的方式进行计算。理论上向量之间的相似度计算公式都可以用来计算用户之间的相似度，但是会根据 实际的情况选择不同的用户相似度度量方法。 </p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics.pairwise <span class="keyword">import</span> cosine_similarity</span><br><span class="line">i = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">j = [<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>]</span><br><span class="line">cosine_similarity([i, j])</span><br></pre></td></tr></table></figure><ol start="3"><li>皮尔逊相关系数<br>皮尔逊相关系数的公式与余弦相似度的计算公式非常的类似，首先对于上述的余弦相似度的计算公式写成求和的形式,其中rui,rvi分别表示用户u和用户v对商品i是否有交互(或者具体的评分值)：<br>$$<br>sim_{uv} = \frac{\sum_i r_{ui}*r_{vi}}{\sqrt{\sum_i r_{ui}^2}\sqrt{\sum_i r_{vi}^2}}<br>$$<br>如下是皮尔逊相关系数计算公式，其中rui,rvi分别表示用户u和用户v对商品i是否有交互（或者具体的评分值），ru拔，rv拔分别表示用户u和v交互的所有商品交互数量或者具体评分的平均值。<br>$$<br>sim(u,v)=\frac{\sum_{i\in I}(r_{ui}-\bar r_u)(r_{vi}-\bar r_v)}{\sqrt{\sum_{i\in I }(r_{ui}-\bar r_u)^2}\sqrt{\sum_{i\in I }(r_{vi}-\bar r_v)^2}}<br>$$</li></ol><p>所以相比余弦相似度，皮尔逊相关系数通过使用用户的平均分对各独立评分进行修正，减小了用户评分偏置的影响。具体实现， 我们也是可以调包， 这个计算方式很多， 下面是其中的一种：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> pearsonr</span><br><span class="line">i = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">j = [<span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>]</span><br><span class="line">pearsonr(i,j)</span><br></pre></td></tr></table></figure></p><hr><h3 id="基于用户的协同过滤"><a href="#基于用户的协同过滤" class="headerlink" title="基于用户的协同过滤"></a>基于用户的协同过滤</h3><p>基于用户的协同过滤（以下用UserCF表示），思想其实比较简单，当一个用户A需要个性化推荐的时候， 我们可以先找到和他有相似兴趣的其他用户， 然后把那些用户喜欢的， 而用户A没有听说过的物品推荐给A。<br>UserCF算法包括两个步骤：<br>1、找到和目标用户兴趣相似的集合<br>2、找到这个集合中用户喜欢的且还没听说过的物品推荐给用户<br>上面的两个步骤中， 第一个步骤里面， 我们会基于前面给出的相似性度量的方法找出与目标用户兴趣相似的用户， 而第二个步骤里面， 如何基于相似用户喜欢的物品来对目标用户进行推荐呢？ 这个要依赖于目标用户对相似用户喜欢的物品的一个喜好程度， 那么如何衡量这个程度大小呢？ 为了更好理解上面的两个步骤， 下面拿一个具体的例子把两个步骤具体化。</p><p>以下图为例，此例将会用于本文各种算法中</p><p><img src="D:\Hexo\themes\next\source\images\十月组队学习_推荐系统_协同算法示例一.jpg" alt="十月组队学习_推荐系统_协同算法示例一"><br>给用户推荐物品的过程可以形象化为一个猜测用户对商品进行打分的任务，上面表格里面是5个用户对于5件物品的一个打分情况，就可以理解为用户对物品的喜欢程度。<br>应用UserCF算法的两个步骤：</p><ol><li>首先根据前面的这些打分情况(或者说已有的用户向量）计算一下Alice和用户1， 2， 3， 4的相似程度， 找出与Alice最相似的n个用户</li><li>根据这n个用户对物品5的评分情况和与Alice的相似程度会猜测出Alice对物品5的评分， 如果评分比较高的话， 就把物品5推荐给用户Alice， 否则不推荐。</li></ol><h4 id="公式分析"><a href="#公式分析" class="headerlink" title="公式分析"></a>公式分析</h4><p>根据上面的几种方法， 我们可以计算出向量之间的相似程度， 也就是可以计算出Alice和其他用户的相近程度， 这时候我们就可以选出与Alice最相近的前n个用户， 基于他们对物品5的评价猜测出Alice的打分值， 那么是怎么计算的呢？<br>这里常用的方式之一是利用用户相似度和相似用户的评价加权平均获得用户的评价预测， 用下面式子表示：<br>$$<br>R_{\mathrm{u}, \mathrm{p}}=\frac{\sum_{\mathrm{s} \in S}\left(w_{\mathrm{u}, \mathrm{s}} \cdot R_{\mathrm{s}, \mathrm{p}}\right)}{\sum_{\mathrm{s} \in S} w_{\mathrm{u}, \mathrm{s}}}<br>$$</p><p>这个式子里面， 权重Wu,s是用户u和用户s的相似度，Rs,p 是用户s对物品p的评分。</p><p>还有一种方式如下， 这种方式考虑的更加全面， 依然是用户相似度作为权值， 但后面不单纯的是其他用户对物品的评分， 而是该物品的评分与此用户的所有评分的差值进行加权平均，这时候考虑到了有的用户内心的评分标准不一的情况， 即有的用户喜欢打高分， 有的用户喜欢打低分的情况。<br>$$<br>P_{i, j}=\bar{R}<em>{i}+\frac{\sum</em>{k=1}^{n}\left(S_{i, k}\left(R_{k, j}-\bar{R}<em>{k}\right)\right)}{\sum</em>{k=1}^{n} S_{i, k}}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;协同过滤&quot;&gt;&lt;a href=&quot;#协同过滤&quot; class=&quot;headerlink&quot; title=&quot;协同过滤&quot;&gt;&lt;/a&gt;协同过滤&lt;/h1&gt;&lt;p&gt;协同过滤（Collaborative Filtering）推荐算法是最经典、最常用的推荐算法。&lt;br&gt;所谓协同过滤， 基本思想是根据用户之前的喜好以及其他兴趣相近的用户的选择来给用户推荐物品(基于对用户历史行为数据的挖掘发现用户的喜好偏向， 并预测用户可能喜好的产品进行推荐)，一般是仅仅基于用户的行为数据（评价、购 买、下载等），而不依赖于项的任何附加信息（物品自身特征）或者用户的任何附加信息（年龄， 性别等）。目前应用比较广泛的协同过滤算法是基于邻域的方法， 而这种方法主要有下面两种算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于用户的协同过滤算法(UserCF):给用户推荐和他兴趣相似的其他用户喜欢的产品&lt;/li&gt;
&lt;li&gt;基于物品的协同过滤算法(ItemCF): 给用户推荐和他之前喜欢的物品相似的物品&lt;br&gt;不管是UserCF还是ItemCF算法， 非常重要的步骤之一就是计算用户和用户或者物品和物品之间的相似度， 所以下面先整理常用的相似性度量方法， 然后再对每个算法的具体细节进行展开。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="推荐系统" scheme="http://yoursite.com/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="推荐系统 协同过滤" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统之召回</title>
    <link href="http://yoursite.com/2020/10/21/2020-10-21%20%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%8F%AC%E5%9B%9E/"/>
    <id>http://yoursite.com/2020/10/21/2020-10-21 推荐系统之召回/</id>
    <published>2020-10-21T08:57:10.000Z</published>
    <updated>2020-10-21T09:09:44.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="召回"><a href="#召回" class="headerlink" title="召回"></a>召回</h1><p>在推荐系统架构中召回层与排序层是推荐系统的核心算法层，而将推荐过程分成召回层与排序层主要是基于工程上的考虑，其中召回阶段负责将海量的候选集快速缩小为几万到几千的规模；而排序层则负责对缩小后的候选集进行精准排 序。所以在召回阶段往往会利用少量的特征和简单的模型对大规模的数据集进行快速的筛选，而在排序层一般会使用更多的特征和更加复杂的模型进行精准的排序。</p><hr><a id="more"></a><h3 id="召回层与排序层的特点"><a href="#召回层与排序层的特点" class="headerlink" title="召回层与排序层的特点"></a>召回层与排序层的特点</h3><ol><li>召回层：待计算的候选集合大、计算速度快、模型简单、特征较少，尽量让用户感兴趣的物品在这个阶段能够被快速召回，即保证相关物品的召回率</li><li>排序层：首要目标是得到精准的排序结果。需要处理的物品数量少，可以利用较多的特征，使用比较复杂的模型。</li></ol><p>在设计召回层时，需要权衡计算速度与召回率，工业上主流的召回方法是采用多个简单策略叠加的多路召回策略。</p><hr><h3 id="多路召回策略"><a href="#多路召回策略" class="headerlink" title="多路召回策略"></a>多路召回策略</h3><p>所谓的“多路召回”策略，就是指采用不同的策略、特征或简单模型，分别召回一部分候选集，然后把候选集混合在一起供<br>后续排序模型使用，可以明显的看出，“多路召回策略”是在“计算速度”和“召回率”之间进行权衡的结果。其中，各种简单<br>策略保证候选集的快速召回，从不同角度设计的策略保证召回率接近理想的状态，不至于影响排序效果。</p><p>如下图是多路召回的一个示意图，在多路召回中，每个策略之间毫不相关，所以一般可以写并发多线程同时进行，这样可以更加高效。</p><p><img src="D:\Hexo\themes\next\source\images\十月组队学习_推荐系统_多路召回.jpg" alt="十月组队学习_推荐系统_多路召回"></p><p>上图只是一个多路召回的例子，也就是说可以使用多种不同的策略来获取用户排序的候选商品集合，而具体使用哪些召回策略其实是与业务强相关的，针对不同的任务就会有对于该业务真实场景下需要考虑的召回规则。例如视频推荐，召回规则可以是“热门视频”、“导演召回”、“演员召回”、“最近上映“、”流行趋势“、”类型召回“等等。</p><h3 id="多路召回存在的问题"><a href="#多路召回存在的问题" class="headerlink" title="多路召回存在的问题"></a>多路召回存在的问题</h3><p>虽然多路召回权衡了计算速度和召回率的问题，可以使得用于排序的候选商品更加的丰富，但是实际的多路召回仍然存在一些问题。如上图所示，对于每一路召回都会从商品集合中拉回K个商品，这里的K是一个超参数，对于K的选择一般需要通过离线评估加线上的A/B测试来确定合理的K值。除此之外，对于不同的任务具体策略的选择也是人工基于经验的选择，选择的策略之间的信息是割裂的，无法总和考虑不同策略对一个物品的影响。</p><hr><h3 id="Embedding-召回"><a href="#Embedding-召回" class="headerlink" title="Embedding 召回"></a>Embedding 召回</h3><h5 id="Embedding是什么？"><a href="#Embedding是什么？" class="headerlink" title="Embedding是什么？"></a>Embedding是什么？</h5><p>Embedding其实是一种思想，主要目的是将稀疏的向量(如one-hot编码)表示转换成稠密的向量，下图直观的显示了one-hot编码和Embedding表示的区别于联系，即Embedding相当于是对one-hot做了平滑，而onehot相当于是对Embedding做了maxpooling。</p><p><img src="D:\Hexo\themes\next\source\images\十月组队学习_推荐系统_Embedding初体验.jpg" alt="十月组队学习_推荐系统_Embedding初体验"></p><p>目前主流的Embedding技术主要可以分为三大类</p><ol><li>text embedding</li><li>image embedding</li><li>graph embedding</li></ol><h5 id="常见的text-Embedding技术"><a href="#常见的text-Embedding技术" class="headerlink" title="常见的text Embedding技术"></a>常见的text Embedding技术</h5><ol><li>静态向量 Word2vec fasttext glove</li><li>动态向量 ELMO GPT BERT</li></ol><hr><h1 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h1><ol><li>为什么使用AUC<br>例如0.7的AUC，其含义可以大概理解为：给定一个正样本和一个负样本，在70%的情况下，模型对正样本的打分高于对负样本的打分。可以看出这个解释下，我们关心的只有正负样本之间的分数高低，而具体的分支则无关紧要【多高的AUC才算高】<br>参考文章 <a href="https://zhuanlan.zhihu.com/p/24217322" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24217322</a></li><li>如何使用Embedding做召回？<br>参考文章<a href="https://zhuanlan.zhihu.com/p/143763320" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/143763320</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;召回&quot;&gt;&lt;a href=&quot;#召回&quot; class=&quot;headerlink&quot; title=&quot;召回&quot;&gt;&lt;/a&gt;召回&lt;/h1&gt;&lt;p&gt;在推荐系统架构中召回层与排序层是推荐系统的核心算法层，而将推荐过程分成召回层与排序层主要是基于工程上的考虑，其中召回阶段负责将海量的候选集快速缩小为几万到几千的规模；而排序层则负责对缩小后的候选集进行精准排 序。所以在召回阶段往往会利用少量的特征和简单的模型对大规模的数据集进行快速的筛选，而在排序层一般会使用更多的特征和更加复杂的模型进行精准的排序。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="推荐系统" scheme="http://yoursite.com/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="推荐系统 Embedding 召回" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-Embedding-%E5%8F%AC%E5%9B%9E/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十六题】最接近的三数之和</title>
    <link href="http://yoursite.com/2019/10/28/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E5%85%AD%E9%A2%98%E3%80%91%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/10/28/Leetcode【第十六题】最接近的三数之和/</id>
    <published>2019-10-28T10:43:10.000Z</published>
    <updated>2019-10-28T11:09:55.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-最接近的三数之和"><a href="#题目-最接近的三数之和" class="headerlink" title="题目 最接近的三数之和"></a>题目 最接近的三数之和</h1><blockquote><p>给定一个包括n 个整数的数组nums和一个目标值target。找出nums中的三个整数，使得它们的和与target最接近。返回这三个数的和。</p><p>假定每组输入只存在唯一答案。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>利用python函数特性 set 和 zip </p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote></blockquote><hr><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def threeSumClosest(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        size = len(nums)</span><br><span class="line">        diff = float(&apos;inf&apos;)</span><br><span class="line">        nums.sort()</span><br><span class="line">        for i in range(size - 2):</span><br><span class="line"></span><br><span class="line">            if i &gt; 0 and nums[i] == nums[i - 1]:</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">            left = i + 1</span><br><span class="line">            right = size - 1</span><br><span class="line">            while left &lt; right:</span><br><span class="line">                s = nums[i] + nums[left] + nums[right]</span><br><span class="line"></span><br><span class="line">                if abs(s - target) &lt; diff:</span><br><span class="line">                    diff = abs(s - target)</span><br><span class="line">                    res = s</span><br><span class="line"></span><br><span class="line">                if s &gt; target:</span><br><span class="line">                    right -= 1</span><br><span class="line">                elif s &lt; target:</span><br><span class="line">                    left += 1</span><br><span class="line">                else:</span><br><span class="line">                    return target</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-最接近的三数之和&quot;&gt;&lt;a href=&quot;#题目-最接近的三数之和&quot; class=&quot;headerlink&quot; title=&quot;题目 最接近的三数之和&quot;&gt;&lt;/a&gt;题目 最接近的三数之和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个包括n 个整数的数组nums和一个目标值target。找出nums中的三个整数，使得它们的和与target最接近。返回这三个数的和。&lt;/p&gt;
&lt;p&gt;假定每组输入只存在唯一答案。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十五题】三数之和</title>
    <link href="http://yoursite.com/2019/10/28/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E4%BA%94%E9%A2%98%E3%80%91%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/10/28/Leetcode【第十五题】三数之和/</id>
    <published>2019-10-28T08:37:12.000Z</published>
    <updated>2019-10-28T11:07:32.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-三数之和"><a href="#题目-三数之和" class="headerlink" title="题目 三数之和"></a>题目 三数之和</h1><blockquote><p>给定一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？</p><p>找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>利用双指针，注意边界和重复</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n2)</p><p>空间复杂度：O(n)</p></blockquote></blockquote><hr><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def threeSum(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if i &gt; 0 and nums[i] == nums[i - 1]:</span><br><span class="line">                continue</span><br><span class="line">            left = i + 1</span><br><span class="line">            right = len(nums) - 1</span><br><span class="line">            while left &lt; right:</span><br><span class="line">                cur_sum = nums[i] + nums[left] + nums[right]</span><br><span class="line">                if cur_sum == 0:</span><br><span class="line">                    tmp = [nums[i], nums[left], nums[right]]</span><br><span class="line">                    res.append(tmp)</span><br><span class="line">                    while left &lt; right and nums[left] == nums[left + 1]:</span><br><span class="line">                        left = left + 1</span><br><span class="line">                    while left &lt; right and nums[right] == nums[right - 1]:</span><br><span class="line">                        right = right - 1</span><br><span class="line">                    left = left + 1</span><br><span class="line">                    right = right - 1</span><br><span class="line">                elif cur_sum &gt; 0:</span><br><span class="line">                    right = right - 1</span><br><span class="line">                else:</span><br><span class="line">                    left = left + 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-三数之和&quot;&gt;&lt;a href=&quot;#题目-三数之和&quot; class=&quot;headerlink&quot; title=&quot;题目 三数之和&quot;&gt;&lt;/a&gt;题目 三数之和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？&lt;/p&gt;
&lt;p&gt;找出所有满足条件且不重复的三元组。&lt;/p&gt;
&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十四题】最长公共前缀</title>
    <link href="http://yoursite.com/2019/10/24/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E5%9B%9B%E9%A2%98%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <id>http://yoursite.com/2019/10/24/Leetcode【第十四题】最长公共前缀/</id>
    <published>2019-10-24T10:47:13.000Z</published>
    <updated>2019-10-28T08:35:23.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-最长公共前缀"><a href="#题目-最长公共前缀" class="headerlink" title="题目 最长公共前缀"></a>题目 最长公共前缀</h1><blockquote><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure><blockquote><p>说明：所有输入只包含小写字母a-z</p></blockquote><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>利用python函数特性 set 和 zip </p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote></blockquote><hr><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res = &quot;&quot;</span><br><span class="line">        for tmp in zip(*strs):</span><br><span class="line">            tmp_set = set(tmp)</span><br><span class="line">            if len(tmp_set) == 1:</span><br><span class="line">                res += tmp[0]</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-最长公共前缀&quot;&gt;&lt;a href=&quot;#题目-最长公共前缀&quot; class=&quot;headerlink&quot; title=&quot;题目 最长公共前缀&quot;&gt;&lt;/a&gt;题目 最长公共前缀&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 “”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode【第十三题】罗马数字转整数</title>
    <link href="http://yoursite.com/2019/10/24/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E4%B8%89%E9%A2%98%E3%80%91%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/24/Leetcode【第十三题】罗马数字转整数/</id>
    <published>2019-10-24T09:58:15.000Z</published>
    <updated>2019-10-24T10:43:42.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-整数转罗马数字"><a href="#题目-整数转罗马数字" class="headerlink" title="题目 整数转罗马数字"></a>题目 整数转罗马数字</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><blockquote><p>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：</p><p>I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。<br>X可以放在L(50) 和C(100) 的左边，来表示 40 和90。<br>C可以放在D(500) 和M(1000) 的左边，来表示400 和900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>此题可用哈希表列表储存几个特殊数值</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def romanToInt(self,s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dic = &#123;&quot;I&quot;: 1, &quot;V&quot;: 5, &quot;X&quot;: 10, &quot;L&quot;: 50, &quot;C&quot;: 100, &quot;D&quot;: 500, &quot;M&quot;: 1000&#125;</span><br><span class="line">        num = 0</span><br><span class="line">        for n, c in enumerate(s[:-1]):</span><br><span class="line">            if dic[c] &gt;= dic[s[n + 1]]:</span><br><span class="line">                num = num + dic[c]</span><br><span class="line">            else:</span><br><span class="line">                num = num - dic[c]</span><br><span class="line">        num = num + dic[s[-1]]</span><br><span class="line">        return num</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-整数转罗马数字&quot;&gt;&lt;a href=&quot;#题目-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;题目 整数转罗马数字&quot;&gt;&lt;/a&gt;题目 整数转罗马数字&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;字符          数值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I             1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;V             5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X             10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;L             50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C             100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D             500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M             1000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;p&gt;I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。&lt;br&gt;X可以放在L(50) 和C(100) 的左边，来表示 40 和90。&lt;br&gt;C可以放在D(500) 和M(1000) 的左边，来表示400 和900。&lt;br&gt;给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十二题】整数转罗马数字</title>
    <link href="http://yoursite.com/2019/10/23/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E4%BA%8C%E9%A2%98%E3%80%91%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2019/10/23/Leetcode【第十二题】整数转罗马数字/</id>
    <published>2019-10-23T11:25:01.000Z</published>
    <updated>2019-10-24T10:43:50.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-整数转罗马数字"><a href="#题目-整数转罗马数字" class="headerlink" title="题目 整数转罗马数字"></a>题目 整数转罗马数字</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><blockquote><p>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：</p><p>I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。<br>X可以放在L(50) 和C(100) 的左边，来表示 40 和90。<br>C可以放在D(500) 和M(1000) 的左边，来表示400 和900。<br>给定一个整数，将其转为罗马数字。输入确保在 1到 3999 的范围内。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>此题可用列表储存几个特殊数值，再用贪心算法求解</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intToRoman(self, num):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type num: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]</span><br><span class="line">        romans = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]</span><br><span class="line"></span><br><span class="line">        index = 0</span><br><span class="line">        res = &apos;&apos;</span><br><span class="line">        while index &lt; 13:</span><br><span class="line">            while num &gt;= nums[index]:</span><br><span class="line">                res = res + romans[index]</span><br><span class="line">                num = num - nums[index]</span><br><span class="line">            index += 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-整数转罗马数字&quot;&gt;&lt;a href=&quot;#题目-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;题目 整数转罗马数字&quot;&gt;&lt;/a&gt;题目 整数转罗马数字&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;字符          数值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I             1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;V             5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X             10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;L             50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C             100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D             500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M             1000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;p&gt;I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。&lt;br&gt;X可以放在L(50) 和C(100) 的左边，来表示 40 和90。&lt;br&gt;C可以放在D(500) 和M(1000) 的左边，来表示400 和900。&lt;br&gt;给定一个整数，将其转为罗马数字。输入确保在 1到 3999 的范围内。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="贪心算法" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十一题】盛最多水的容器</title>
    <link href="http://yoursite.com/2019/10/23/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E4%B8%80%E9%A2%98%E3%80%91%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/10/23/Leetcode【第十一题】盛最多水的容器/</id>
    <published>2019-10-23T10:25:01.000Z</published>
    <updated>2019-10-24T10:43:54.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-盛最多水的容器"><a href="#题目-盛最多水的容器" class="headerlink" title="题目 盛最多水的容器"></a>题目 盛最多水的容器</h1><blockquote><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai) 和 (i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且n的值至少为 2。</p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>由题易得：由线段形成的区域总是受到较短的那个线段以及两者间的距离决定。</p><p>移动指向较短线段的指针尽管造成了矩形宽度的减小，但却可能会有助于面积的增大。</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，遍历一遍整数字符串</p><p>空间复杂度：O(1)，存储容量为定值</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxArea(self, height):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type height: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        i, j, res = 0, len(height) - 1, 0</span><br><span class="line">        while i &lt; j:</span><br><span class="line">            min_height = min(height[i], height[j])</span><br><span class="line">            res = max(res, min_height * (j - i))</span><br><span class="line">            if height[i] &lt; height[j]:</span><br><span class="line">                i += 1</span><br><span class="line">            else:</span><br><span class="line">                j -= 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-盛最多水的容器&quot;&gt;&lt;a href=&quot;#题目-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;题目 盛最多水的容器&quot;&gt;&lt;/a&gt;题目 盛最多水的容器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai) 和 (i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;说明：你不能倾斜容器，且n的值至少为 2。&lt;/p&gt;
&lt;p&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="双指针法" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十题】正则表达式匹配</title>
    <link href="http://yoursite.com/2019/10/19/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E9%A2%98%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2019/10/19/Leetcode【第十题】正则表达式匹配/</id>
    <published>2019-10-19T10:23:43.000Z</published>
    <updated>2019-10-23T10:24:43.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-正则表达式匹配"><a href="#题目-正则表达式匹配" class="headerlink" title="题目 正则表达式匹配"></a>题目 正则表达式匹配</h1><blockquote><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘<em>‘ 的正则表达式匹配<br>‘.’ 匹配任意单个字符<br>‘</em>‘ 匹配零个或多个前面的那一个元素</p><p>所谓匹配，是要涵盖 整个字符串s的，而不是部分字符串。</p><p>说明:</p><pre><code>s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</code></pre></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>动态规划</p></blockquote><p><code>动态规划四要素</code></p><blockquote><p>状态</p><p>转移方程</p><p>初始化</p><p>结果</p></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-正则表达式匹配&quot;&gt;&lt;a href=&quot;#题目-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;题目 正则表达式匹配&quot;&gt;&lt;/a&gt;题目 正则表达式匹配&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘&lt;em&gt;‘ 的正则表达式匹配&lt;br&gt;‘.’ 匹配任意单个字符&lt;br&gt;‘&lt;/em&gt;‘ 匹配零个或多个前面的那一个元素&lt;/p&gt;
&lt;p&gt;所谓匹配，是要涵盖 整个字符串s的，而不是部分字符串。&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s 可能为空，且只包含从 a-z 的小写字母。

p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第九题】回文数</title>
    <link href="http://yoursite.com/2019/10/19/Leetcode%E3%80%90%E7%AC%AC%E4%B9%9D%E9%A2%98%E3%80%91%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/19/Leetcode【第九题】回文数/</id>
    <published>2019-10-19T08:23:43.000Z</published>
    <updated>2019-10-19T09:26:55.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-回文数"><a href="#题目-回文数" class="headerlink" title="题目 回文数"></a>题目 回文数</h1><blockquote><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>进阶:你能不将整数转为字符串来解决这个问题吗？</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>字符串解法：非负整数，反转，判断是否相等</p><p>非字符串解法：计算位数和余数，寻找对应关系</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(max(n,n/2))</p><p>空间复杂度：O(n)</p></blockquote></blockquote><p><code>pytho 除法运算符</code></p><blockquote><p>// 向下整除</p><p>% 取余</p></blockquote><hr><h4 id="代码1-字符串解法"><a href="#代码1-字符串解法" class="headerlink" title="代码1 字符串解法"></a>代码1 字符串解法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x: int) -&gt; bool:        </span><br><span class="line">        if str(x) == str(x)[::-1]:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure><h4 id="代码2-除法解法"><a href="#代码2-除法解法" class="headerlink" title="代码2 除法解法"></a>代码2 除法解法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x: int) -&gt; bool:        </span><br><span class="line">        if (x &lt; 0) or (x != 0 and x % 10 == 0):</span><br><span class="line">            return False</span><br><span class="line">        cmp_num = 0</span><br><span class="line">        while x &gt; cmp_num:</span><br><span class="line">            cmp_num = cmp_num * 10 + x % 10</span><br><span class="line">            x //= 10</span><br><span class="line">        return x == cmp_num or x == cmp_num // 10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-回文数&quot;&gt;&lt;a href=&quot;#题目-回文数&quot; class=&quot;headerlink&quot; title=&quot;题目 回文数&quot;&gt;&lt;/a&gt;题目 回文数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;p&gt;进阶:你能不将整数转为字符串来解决这个问题吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="回文数" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第八题】字符串转换整数（atoi）</title>
    <link href="http://yoursite.com/2019/10/19/Leetcode%E3%80%90%E7%AC%AC%E5%85%AB%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%EF%BC%88atoi%EF%BC%89/"/>
    <id>http://yoursite.com/2019/10/19/Leetcode【第八题】字符串转换整数（atoi）/</id>
    <published>2019-10-19T08:09:07.000Z</published>
    <updated>2019-10-19T08:09:38.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-字符串转换整数"><a href="#题目-字符串转换整数" class="headerlink" title="题目 字符串转换整数"></a>题目 字符串转换整数</h1><blockquote><p>请你来实现一个atoi函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为[−231, 231− 1]。如果数值超过这个范围，请返回INT_MAX (231− 1) 或INT_MIN (−231) 。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。</span><br><span class="line">因此无法执行有效的转换。</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>考验循环中附加条件的位置关系 ==这题比较恶心，想尝试简化流程，但很难。==</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，遍历一遍整数字符串</p><p>空间复杂度：O(n)，总长最长为整数字符串长度</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def myAtoi(self, str):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type str: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        raw_str = str</span><br><span class="line">        </span><br><span class="line">        # 可靠字符集</span><br><span class="line">        valid_set = </span><br><span class="line">        &#123;</span><br><span class="line">            &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, </span><br><span class="line">            &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;,</span><br><span class="line">            &apos;+&apos;, &apos;-&apos;, &apos; &apos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        # 数字字符集</span><br><span class="line">        num_set = </span><br><span class="line">        &#123;</span><br><span class="line">        &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, </span><br><span class="line">        &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        # 正负字符集</span><br><span class="line">        sign_set = &#123;&apos;+&apos;, &apos;-&apos;&#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        k = 0  # 当前位置</span><br><span class="line">        m = 0  # 正负计数符</span><br><span class="line">        p = 0  # 空格位置符</span><br><span class="line">        n = 0  # 正负位置符</span><br><span class="line">        i = 0  # 位数</span><br><span class="line"></span><br><span class="line">        tmp_str = &apos;&apos;</span><br><span class="line"></span><br><span class="line">        if len(raw_str) == 0:</span><br><span class="line">        # 【可能性】 空字符串</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        if raw_str[0] not in valid_set:</span><br><span class="line">        # 【可能性】 非可靠字符串</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        for s in raw_str:</span><br><span class="line">        </span><br><span class="line">            if s in sign_set:</span><br><span class="line">                if i &gt; 0:</span><br><span class="line">                    break</span><br><span class="line">                m = m + 1</span><br><span class="line">                n = k</span><br><span class="line">                # 【可能性】 字符串含超过1个正负号</span><br><span class="line">                if m &gt; 1:</span><br><span class="line">                    return 0</span><br><span class="line">                    </span><br><span class="line">            if s == &apos; &apos;:</span><br><span class="line">                if i &gt; 0:</span><br><span class="line">                    break</span><br><span class="line">                p = k</span><br><span class="line"></span><br><span class="line">            if s in num_set:</span><br><span class="line">                # 【可能性】 正负号后跟空格</span><br><span class="line">                if p &gt; n and m &gt; 0:</span><br><span class="line">                    return 0</span><br><span class="line">                i = i + 1</span><br><span class="line">                tmp_str = tmp_str + s</span><br><span class="line"></span><br><span class="line">            if s not in valid_set:</span><br><span class="line">                k = k + 1</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            k = k + 1</span><br><span class="line"></span><br><span class="line">        if i == 0:</span><br><span class="line">            return 0</span><br><span class="line">        else:</span><br><span class="line">            if m &gt; 0:</span><br><span class="line">                tmp_str = raw_str[n] + tmp_str</span><br><span class="line"></span><br><span class="line">        covert_int = int(tmp_str)</span><br><span class="line"></span><br><span class="line">        # 越界判断</span><br><span class="line">        if covert_int &gt;= 2**31 - 1:</span><br><span class="line">            return 2**31 - 1</span><br><span class="line">        if covert_int &lt;= (-2**31):</span><br><span class="line">            return (-2**31)</span><br><span class="line"></span><br><span class="line">        return covert_int</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-字符串转换整数&quot;&gt;&lt;a href=&quot;#题目-字符串转换整数&quot; class=&quot;headerlink&quot; title=&quot;题目 字符串转换整数&quot;&gt;&lt;/a&gt;题目 字符串转换整数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;请你来实现一个atoi函数，使其能将字符串转换成整数。&lt;/p&gt;
&lt;p&gt;首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。&lt;/p&gt;
&lt;p&gt;当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。&lt;/p&gt;
&lt;p&gt;该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。&lt;/p&gt;
&lt;p&gt;注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。&lt;/p&gt;
&lt;p&gt;在任何情况下，若函数不能进行有效的转换时，请返回 0。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为[−231, 231− 1]。如果数值超过这个范围，请返回INT_MAX (231− 1) 或INT_MIN (−231) 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="编程基础" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第七题】整数反转</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%B8%83%E9%A2%98%E3%80%91%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第七题】整数反转/</id>
    <published>2019-10-16T09:44:07.000Z</published>
    <updated>2019-10-16T09:47:51.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-整数反转"><a href="#题目-整数反转" class="headerlink" title="题目 整数反转"></a>题目 整数反转</h1><blockquote><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>注意:<br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为[−231, 231− 1]。</p><p>请根据这个假设，如果反转后整数溢出那么就返回 0。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>考验对基本函数的熟悉程度</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，遍历一遍整数字符串</p><p>空间复杂度：O(n)，总长为整数字符串长度</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def reverse(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        list_str_x = list(str(abs(x)))</span><br><span class="line"></span><br><span class="line">        res = int(&apos;&apos;.join(list_str_x[::-1]))</span><br><span class="line">        if res &lt; -  2147483648 or res &gt; 2147483647 :</span><br><span class="line">            res = 0</span><br><span class="line">        return res if x &gt; 0 else - res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-整数反转&quot;&gt;&lt;a href=&quot;#题目-整数反转&quot; class=&quot;headerlink&quot; title=&quot;题目 整数反转&quot;&gt;&lt;/a&gt;题目 整数反转&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为[−231, 231− 1]。&lt;/p&gt;
&lt;p&gt;请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode【第六题】Z字形变换</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E5%85%AD%E9%A2%98%E3%80%91z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第六题】z字形变换/</id>
    <published>2019-10-16T09:42:07.000Z</published>
    <updated>2019-10-16T09:47:30.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-Z字形变换"><a href="#题目-Z字形变换" class="headerlink" title="题目 Z字形变换"></a>题目 Z字形变换</h1><blockquote><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “LEETCODEISHIRING”行数为 3 时，排列如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><blockquote><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>找到Z字的转折点规律是关键</p><p>标记示例字符串各字符所在行数 ==’LDREOEIIECIHNTSG’==</p><p>L E E T C O D E I S H I R I N G</p><p>1 2 3 2 1 2 3 2 1 2 3 2 1 2 3 2</p><p>L E E T C O D E I S H I R I N G</p><p>1 2 3 4 3 2 1 2 3 4 3 2 1 2 3 4</p><p>易得规律：转折点在[1,numRows]两端反复</p><p>定义一个计数器，记录当前行数与给定行数间的关系，当行数为1或等于给定行数时，取相反数</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，遍历一遍字符串</p><p>空间复杂度：O(n)，需要对应的列表存储，总长为字符串长度</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def convert(self, s, numRows):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :type numRows: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 行数小于2，直接返回</span><br><span class="line">        if numRows &lt; 2:</span><br><span class="line">            return s</span><br><span class="line">        </span><br><span class="line">        # 以字符串构建行列表</span><br><span class="line">        res = [&apos;&apos; for i in range(numRows)]</span><br><span class="line"></span><br><span class="line">        spot = - 1 # 转折点</span><br><span class="line">        n = 1 # 计数器</span><br><span class="line">        for str_ in s:</span><br><span class="line">            res[n - 1] = res[n - 1] + str_</span><br><span class="line">            if n == 1 or n == numRows:</span><br><span class="line">                spot = - spot</span><br><span class="line">            n = n + spot</span><br><span class="line"></span><br><span class="line">        return &apos;&apos;.join(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-Z字形变换&quot;&gt;&lt;a href=&quot;#题目-Z字形变换&quot; class=&quot;headerlink&quot; title=&quot;题目 Z字形变换&quot;&gt;&lt;/a&gt;题目 Z字形变换&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;br&gt;比如输入字符串为 “LEETCODEISHIRING”行数为 3 时，排列如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;L   C   I   R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E T O E S I I G&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E   D   H   N&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode【第五题】最长回文子串</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%BA%94%E9%A2%98%E3%80%91%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第五题】最长回文子串/</id>
    <published>2019-10-16T06:12:07.000Z</published>
    <updated>2019-10-16T06:13:02.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-最长回文子串"><a href="#题目-最长回文子串" class="headerlink" title="题目 最长回文子串"></a>题目 最长回文子串</h1><blockquote><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>在有序数组中，寻找一个索引i ，使得<br>索引左边的数小于等于索引右边的数</p><p>当两个数组的元素之和为奇数时，size 左 = size 右 + 1</p><p>当两个数组的元素之和为偶数时，size 左 = size 右</p><p>考虑边界线附近的划分</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(n²)，需要二维数对存储状态</p></blockquote></blockquote><p><code>and 和 or 的短路原则</code></p><blockquote><p>对于 and 来说：</p><p>如果第一个条件的结论为假，那么 and 前后两个条件组成的表达式计算结果一定为假，后面的条件计算机不会进行计算</p><p>对于 or 来说：</p><p>如果第一个条件的结论为真，那么 or 前后两个条件组成的表达式计算结果一定为真，后面的条件计算机不会进行计算</p></blockquote><hr><p><code>动态规划 dynamic programming</code></p><blockquote><p>1、定义 “状态”；</p><p>2、找到 “状态转移方程”。</p></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def longestPalindrome(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        size = len(s)</span><br><span class="line">        if size &lt;= 1:</span><br><span class="line">            return s</span><br><span class="line">        # 二维 dp 问题</span><br><span class="line">        dp = [[False for _ in range(size)] for _ in range(size)]</span><br><span class="line">    </span><br><span class="line">        longest_l = 1</span><br><span class="line">        res = s[0]</span><br><span class="line">    </span><br><span class="line">        # 左边界一定要比右边界小，因此右边界从 1 开始</span><br><span class="line">        for right_ in range(1, size):</span><br><span class="line">            for left_ in range(right_):</span><br><span class="line">                # 状态转移方程：如果头尾字符相等并且中间也是回文</span><br><span class="line">                if s[left_] == s[right_] and (right_ - left_ &lt;= 2 or dp[left_ + 1][right_ - 1]):</span><br><span class="line">                    # 更新状态</span><br><span class="line">                    dp[left_][right_] = True</span><br><span class="line">                    cur_len = right_ - left_ + 1</span><br><span class="line">                    if cur_len &gt; longest_l:</span><br><span class="line">                        longest_l = cur_len</span><br><span class="line">                        res = s[left_:right_ + 1]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-最长回文子串&quot;&gt;&lt;a href=&quot;#题目-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;题目 最长回文子串&quot;&gt;&lt;/a&gt;题目 最长回文子串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="回文" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第四题】寻找两个有序数组的中位数</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E5%9B%9B%E9%A2%98%E3%80%91%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第四题】寻找两个有序数组的中位数/</id>
    <published>2019-10-16T06:10:07.000Z</published>
    <updated>2019-10-16T06:14:27.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-寻找两个有序数组的中位数"><a href="#题目-寻找两个有序数组的中位数" class="headerlink" title="题目 寻找两个有序数组的中位数"></a>题目 寻找两个有序数组的中位数</h1><blockquote><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>在有序数组中，寻找一个索引i ，使得<br>索引左边的数小于等于索引右边的数</p><p>当两个数组的元素之和为奇数时，size 左 = size 右 + 1</p><p>当两个数组的元素之和为偶数时，size 左 = size 右</p><p>考虑边界线附近的划分</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(log(min(m,n)))</p><p>查找区间为[0,m]，该区间的长度在每次循环后都会减少一半。所以，我们只需要执行 log(m) 次循环。</p><p>由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log(m))。<br>由于 m≤n，所以时间复杂度是 O(log({min}(m,n)))。</p><p>空间复杂度：O(1)，<br>只需存储几个局部变量</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def findMedianSortedArrays(A, B):</span><br><span class="line">    m, n = len(A), len(B)</span><br><span class="line">    if m &gt; n:</span><br><span class="line">        A, B, m, n = B, A, n, m</span><br><span class="line">    if n == 0:</span><br><span class="line">        raise ValueError</span><br><span class="line"></span><br><span class="line">    imin, imax, half_len = 0, m, (m + n + 1) / 2</span><br><span class="line">    while imin &lt;= imax:</span><br><span class="line">        i = (imin + imax) / 2</span><br><span class="line">        j = half_len - i</span><br><span class="line">        if i &lt; m and B[j-1] &gt; A[i]:</span><br><span class="line">            imin = i + 1</span><br><span class="line">        elif i &gt; 0 and A[i-1] &gt; B[j]:</span><br><span class="line">            imax = i - 1</span><br><span class="line">        else:</span><br><span class="line">            if i == 0: max_of_left = B[j-1]</span><br><span class="line">            elif j == 0: max_of_left = A[i-1]</span><br><span class="line">            else: max_of_left = max(A[i-1], B[j-1])</span><br><span class="line"></span><br><span class="line">            if (m + n) % 2 == 1:</span><br><span class="line">                return max_of_left</span><br><span class="line"></span><br><span class="line">            if i == m: min_of_right = B[j]</span><br><span class="line">            elif j == n: min_of_right = A[i]</span><br><span class="line">            else: min_of_right = min(A[i], B[j])</span><br><span class="line"></span><br><span class="line">            return (max_of_left + min_of_right) / 2.0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-寻找两个有序数组的中位数&quot;&gt;&lt;a href=&quot;#题目-寻找两个有序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;题目 寻找两个有序数组的中位数&quot;&gt;&lt;/a&gt;题目 寻找两个有序数组的中位数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;/p&gt;
&lt;p&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;/p&gt;
&lt;p&gt;你可以假设 nums1 和 nums2 不会同时为空。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="二分法" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第三题】无重复字符串的最长子串</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%B8%89%E9%A2%98%E3%80%91%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第三题】无重复字符串的最长子串/</id>
    <published>2019-10-16T06:09:07.000Z</published>
    <updated>2019-10-16T06:22:58.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-无重复字符串的最长子串"><a href="#题目-无重复字符串的最长子串" class="headerlink" title="题目 无重复字符串的最长子串"></a>题目 无重复字符串的最长子串</h1><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是&quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot;是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>滑动窗口是数组/字符串问题中常用的抽象概念。</p><p>窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j)向右滑动 1 个元素，则它将变为 [i+1, j+1)（左闭，右开）。</p><p>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j)（最初 j = i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n) or O(2n)</p><p>空间复杂度：O(min(m,n))，<br>滑动窗口的大小为所求子串的最大长度 k。k取决于 m,n 两者的最小值</p></blockquote></blockquote><hr><h4 id="代码-1-有添加删除动作的滑动窗口"><a href="#代码-1-有添加删除动作的滑动窗口" class="headerlink" title="代码 1 有添加删除动作的滑动窗口"></a>代码 1 有添加删除动作的滑动窗口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 缺点是真实增删数据，内存消耗严重</span><br><span class="line">class Solution(object):</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 如果字符串s为空，返回0</span><br><span class="line">        if not s:</span><br><span class="line">            return 0</span><br><span class="line">    </span><br><span class="line">        Sliding_window = []</span><br><span class="line">        max_len = 0</span><br><span class="line">        cur_len = 0</span><br><span class="line">    </span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            char_val = s[i]</span><br><span class="line">            # 如果该值不在窗口中</span><br><span class="line">            if char_val not in Sliding_window:</span><br><span class="line">                Sliding_window.append(char_val)</span><br><span class="line">                cur_len = cur_len + 1</span><br><span class="line">    </span><br><span class="line">            # 如果该值在窗口中已存在</span><br><span class="line">            else:</span><br><span class="line">                index = Sliding_window.index(char_val)</span><br><span class="line">                # 移除该位置及之前的所有字符</span><br><span class="line">                Sliding_window = Sliding_window[index+1:]</span><br><span class="line">                Sliding_window.append(char_val)</span><br><span class="line">                cur_len = len(Sliding_window)</span><br><span class="line">    </span><br><span class="line">            if cur_len &gt; max_len:</span><br><span class="line">                max_len = cur_len</span><br><span class="line">    </span><br><span class="line">        return max_len</span><br></pre></td></tr></table></figure><hr><h4 id="代码-2-模拟左右指针的滑动窗口"><a href="#代码-2-模拟左右指针的滑动窗口" class="headerlink" title="代码 2 模拟左右指针的滑动窗口"></a>代码 2 模拟左右指针的滑动窗口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 优点是不直接操作窗口</span><br><span class="line">class Solution(object):</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 如果字符串s为空，返回0</span><br><span class="line">        if not s:</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        Sliding_window = s</span><br><span class="line">        max_len = 0      # 滑动窗口数组</span><br><span class="line">        left, right = 0, 0  # 双指针</span><br><span class="line">    </span><br><span class="line">        for i, char_val in enumerate(Sliding_window):</span><br><span class="line">            # 如果该值不在窗口中</span><br><span class="line">            if char_val not in Sliding_window[left:right]:</span><br><span class="line">                right = right + 1</span><br><span class="line">            # 如果该值在窗口中已存在，移除该位置及之前的所有字符</span><br><span class="line">            else:</span><br><span class="line">                # 左指针 右指针 右移一位</span><br><span class="line">                left = left + Sliding_window[left:right].index(char_val) + 1</span><br><span class="line">                right = right + 1</span><br><span class="line">    </span><br><span class="line">            # 更新最大长度</span><br><span class="line">            max_len = max(right - left, max_len)</span><br><span class="line"></span><br><span class="line">        return max_len if max_len != 0 else len(Sliding_window)</span><br></pre></td></tr></table></figure><hr><h4 id="代码-3-哈希表"><a href="#代码-3-哈希表" class="headerlink" title="代码 3 ==哈希表=="></a>代码 3 ==哈希表==</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def lengthOfLongestSubstring(self, s):</span><br><span class="line"></span><br><span class="line">    # 可抛弃字符串的索引尾值 - 字符串索引值，该索引值以及之前的字符都属于重复字符串中的一部分，不再在计算中涉及</span><br><span class="line">    ignore_str_index_end = -1</span><br><span class="line">    dic = &#123;&#125;  # 任意字符最后出现在索引的位置 - &#123;字符: 字符索引值&#125;</span><br><span class="line">    max_len = 0  # 最长字符串长度</span><br><span class="line"></span><br><span class="line">    for i, char_val in enumerate(s):</span><br><span class="line">        # 如果字典中已经存在字符char_val，则字符char_val重复</span><br><span class="line">        # 先更新可抛弃字符串的索引尾值为字符char_val上一次的索引值</span><br><span class="line">        if char_val in dic and dic[char_val] &gt; ignore_str_index_end:</span><br><span class="line">            ignore_str_index_end = dic[char_val]</span><br><span class="line">            # 再更新字符char_val的索引值</span><br><span class="line">            dic[char_val] = i</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            # 更新字符最近的索引位置</span><br><span class="line">            dic[char_val] = i</span><br><span class="line">            # 更新最大长度</span><br><span class="line">            max_len = max(dic[char_val] - ignore_str_index_end, max_len)</span><br><span class="line"></span><br><span class="line">    return max_len</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-无重复字符串的最长子串&quot;&gt;&lt;a href=&quot;#题目-无重复字符串的最长子串&quot; class=&quot;headerlink&quot; title=&quot;题目 无重复字符串的最长子串&quot;&gt;&lt;/a&gt;题目 无重复字符串的最长子串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第二题】两数相加</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%BA%8C%E9%A2%98%E3%80%91%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第二题】两数相加/</id>
    <published>2019-10-16T05:51:44.000Z</published>
    <updated>2019-10-16T06:12:41.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-两数相加"><a href="#题目-两数相加" class="headerlink" title="题目 两数相加"></a>题目 两数相加</h1><blockquote><p>给出两个非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0开头。</p></blockquote><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表l1和l2的表头开始相加。由于每位数字都应当处于0…9的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为2，并将进位carry = 1带入下一次迭代。进位carry必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(max(m,n))，<br>假设m和n分别为l1,l2的长度，数位相加，最多运算max(m,n),所以时间复杂度为 O(max(m,n))。</p><p>空间复杂度：O(max(m,n))，<br>新列表的长度最多为max(m,n)+1。</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line">class ListNode(object):</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def addTwoNumbers(self, n, m):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type n: ListNode</span><br><span class="line">        :type m: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 两次循环将列表转换为数值 step 1</span><br><span class="line">        carry_bit = 1   # 进位符 carry bit</span><br><span class="line">        num_l1 = 0</span><br><span class="line">        while n:</span><br><span class="line">            num_l1 = num_l1 + n.val * carry_bit</span><br><span class="line">            carry_bit = carry_bit * 10</span><br><span class="line">            n = n.next</span><br><span class="line"></span><br><span class="line">        # 两次循环将列表转换为数值 step 2</span><br><span class="line">        carry_bit = 1</span><br><span class="line">        num_l2 = 0</span><br><span class="line">        while m:</span><br><span class="line">            num_l2 = num_l2 + m.val * carry_bit</span><br><span class="line">            carry_bit = carry_bit * 10</span><br><span class="line">            m = m.next</span><br><span class="line"></span><br><span class="line">        # 转换成字符串</span><br><span class="line">        str_num = str(num_l1 + num_l2)</span><br><span class="line">        # 倒序排列</span><br><span class="line">        str_num = str_num[::-1]</span><br><span class="line">        res = list_result = ListNode(0)</span><br><span class="line"></span><br><span class="line">        for num in str_num:</span><br><span class="line">            list_result.next = ListNode(int(num))</span><br><span class="line">            list_result = list_result.next</span><br><span class="line">        return res.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-两数相加&quot;&gt;&lt;a href=&quot;#题目-两数相加&quot; class=&quot;headerlink&quot; title=&quot;题目 两数相加&quot;&gt;&lt;/a&gt;题目 两数相加&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给出两个非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。&lt;/p&gt;
&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;
&lt;p&gt;您可以假设除了数字 0 之外，这两个数都不会以 0开头。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="计算符号" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E7%AC%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第一题】两数之和</title>
    <link href="http://yoursite.com/2019/10/14/Leetcode%E3%80%90%E7%AC%AC%E4%B8%80%E9%A2%98%E3%80%91%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/10/14/Leetcode【第一题】两数之和/</id>
    <published>2019-10-14T06:23:07.000Z</published>
    <updated>2019-10-16T06:12:32.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-两数之和"><a href="#题目-两数之和" class="headerlink" title="题目 两数之和"></a>题目 两数之和</h1><blockquote><p>给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p></blockquote><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><hr><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><blockquote><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？==哈希表==。</p><p>通过==以空间换取速度==的方式，我们可以将查找时间从 ==O(n)降低到 O(1)==。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。</p><p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，<br>我们把包含有 n个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。</p><p>空间复杂度：O(n)，<br>所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。</p></blockquote></blockquote><hr><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        for ind,num in enumerate(nums): # 第一次迭代创建哈希表</span><br><span class="line">            hashmap[num] = ind</span><br><span class="line">        for i,num in enumerate(nums):</span><br><span class="line">            j = hashmap.get(target - num)</span><br><span class="line">            if j is not None and i!=j:</span><br><span class="line">                return [i,j]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-两数之和&quot;&gt;&lt;a href=&quot;#题目-两数之和&quot; class=&quot;headerlink&quot; title=&quot;题目 两数之和&quot;&gt;&lt;/a&gt;题目 两数之和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。&lt;br&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
