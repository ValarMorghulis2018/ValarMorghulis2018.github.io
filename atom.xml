<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>六姐的博客</title>
  
  <subtitle>Valar Morghulis</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-24T10:43:42.248Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Six Sister</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode【第十三题】罗马数字转整数</title>
    <link href="http://yoursite.com/2019/10/24/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E4%B8%89%E9%A2%98%E3%80%91%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/24/Leetcode【第十三题】罗马数字转整数/</id>
    <published>2019-10-24T09:58:15.000Z</published>
    <updated>2019-10-24T10:43:42.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-整数转罗马数字"><a href="#题目-整数转罗马数字" class="headerlink" title="题目 整数转罗马数字"></a>题目 整数转罗马数字</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><blockquote><p>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：</p><p>I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。<br>X可以放在L(50) 和C(100) 的左边，来表示 40 和90。<br>C可以放在D(500) 和M(1000) 的左边，来表示400 和900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>此题可用哈希表列表储存几个特殊数值</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def romanToInt(self,s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dic = &#123;&quot;I&quot;: 1, &quot;V&quot;: 5, &quot;X&quot;: 10, &quot;L&quot;: 50, &quot;C&quot;: 100, &quot;D&quot;: 500, &quot;M&quot;: 1000&#125;</span><br><span class="line">        num = 0</span><br><span class="line">        for n, c in enumerate(s[:-1]):</span><br><span class="line">            if dic[c] &gt;= dic[s[n + 1]]:</span><br><span class="line">                num = num + dic[c]</span><br><span class="line">            else:</span><br><span class="line">                num = num - dic[c]</span><br><span class="line">        num = num + dic[s[-1]]</span><br><span class="line">        return num</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-整数转罗马数字&quot;&gt;&lt;a href=&quot;#题目-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;题目 整数转罗马数字&quot;&gt;&lt;/a&gt;题目 整数转罗马数字&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;字符          数值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I             1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;V             5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X             10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;L             50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C             100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D             500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M             1000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;p&gt;I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。&lt;br&gt;X可以放在L(50) 和C(100) 的左边，来表示 40 和90。&lt;br&gt;C可以放在D(500) 和M(1000) 的左边，来表示400 和900。&lt;br&gt;给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十二题】整数转罗马数字</title>
    <link href="http://yoursite.com/2019/10/23/leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E4%BA%8C%E9%A2%98%E3%80%91%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2019/10/23/leetcode【第十二题】整数转罗马数字/</id>
    <published>2019-10-23T11:25:01.000Z</published>
    <updated>2019-10-24T10:43:50.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-整数转罗马数字"><a href="#题目-整数转罗马数字" class="headerlink" title="题目 整数转罗马数字"></a>题目 整数转罗马数字</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><blockquote><p>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：</p><p>I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。<br>X可以放在L(50) 和C(100) 的左边，来表示 40 和90。<br>C可以放在D(500) 和M(1000) 的左边，来表示400 和900。<br>给定一个整数，将其转为罗马数字。输入确保在 1到 3999 的范围内。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>此题可用列表储存几个特殊数值，再用贪心算法求解</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intToRoman(self, num):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type num: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]</span><br><span class="line">        romans = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]</span><br><span class="line"></span><br><span class="line">        index = 0</span><br><span class="line">        res = &apos;&apos;</span><br><span class="line">        while index &lt; 13:</span><br><span class="line">            while num &gt;= nums[index]:</span><br><span class="line">                res = res + romans[index]</span><br><span class="line">                num = num - nums[index]</span><br><span class="line">            index += 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-整数转罗马数字&quot;&gt;&lt;a href=&quot;#题目-整数转罗马数字&quot; class=&quot;headerlink&quot; title=&quot;题目 整数转罗马数字&quot;&gt;&lt;/a&gt;题目 整数转罗马数字&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;字符          数值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I             1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;V             5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X             10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;L             50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C             100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;D             500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;M             1000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。&lt;/p&gt;
&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;
&lt;p&gt;I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。&lt;br&gt;X可以放在L(50) 和C(100) 的左边，来表示 40 和90。&lt;br&gt;C可以放在D(500) 和M(1000) 的左边，来表示400 和900。&lt;br&gt;给定一个整数，将其转为罗马数字。输入确保在 1到 3999 的范围内。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="贪心算法" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十一题】盛最多水的容器</title>
    <link href="http://yoursite.com/2019/10/23/leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E4%B8%80%E9%A2%98%E3%80%91%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2019/10/23/leetcode【第十一题】盛最多水的容器/</id>
    <published>2019-10-23T10:25:01.000Z</published>
    <updated>2019-10-24T10:43:54.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-盛最多水的容器"><a href="#题目-盛最多水的容器" class="headerlink" title="题目 盛最多水的容器"></a>题目 盛最多水的容器</h1><blockquote><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai) 和 (i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且n的值至少为 2。</p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>由题易得：由线段形成的区域总是受到较短的那个线段以及两者间的距离决定。</p><p>移动指向较短线段的指针尽管造成了矩形宽度的减小，但却可能会有助于面积的增大。</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，遍历一遍整数字符串</p><p>空间复杂度：O(1)，存储容量为定值</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxArea(self, height):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type height: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        i, j, res = 0, len(height) - 1, 0</span><br><span class="line">        while i &lt; j:</span><br><span class="line">            min_height = min(height[i], height[j])</span><br><span class="line">            res = max(res, min_height * (j - i))</span><br><span class="line">            if height[i] &lt; height[j]:</span><br><span class="line">                i += 1</span><br><span class="line">            else:</span><br><span class="line">                j -= 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-盛最多水的容器&quot;&gt;&lt;a href=&quot;#题目-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;题目 盛最多水的容器&quot;&gt;&lt;/a&gt;题目 盛最多水的容器&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai) 和 (i, 0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;说明：你不能倾斜容器，且n的值至少为 2。&lt;/p&gt;
&lt;p&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="双指针法" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第十题】正则表达式匹配</title>
    <link href="http://yoursite.com/2019/10/19/Leetcode%E3%80%90%E7%AC%AC%E5%8D%81%E9%A2%98%E3%80%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2019/10/19/Leetcode【第十题】正则表达式匹配/</id>
    <published>2019-10-19T10:23:43.000Z</published>
    <updated>2019-10-23T10:24:43.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-正则表达式匹配"><a href="#题目-正则表达式匹配" class="headerlink" title="题目 正则表达式匹配"></a>题目 正则表达式匹配</h1><blockquote><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘<em>‘ 的正则表达式匹配<br>‘.’ 匹配任意单个字符<br>‘</em>‘ 匹配零个或多个前面的那一个元素</p><p>所谓匹配，是要涵盖 整个字符串s的，而不是部分字符串。</p><p>说明:</p><pre><code>s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</code></pre></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>动态规划</p></blockquote><p><code>动态规划四要素</code></p><blockquote><p>状态</p><p>转移方程</p><p>初始化</p><p>结果</p></blockquote><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-正则表达式匹配&quot;&gt;&lt;a href=&quot;#题目-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;题目 正则表达式匹配&quot;&gt;&lt;/a&gt;题目 正则表达式匹配&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘&lt;em&gt;‘ 的正则表达式匹配&lt;br&gt;‘.’ 匹配任意单个字符&lt;br&gt;‘&lt;/em&gt;‘ 匹配零个或多个前面的那一个元素&lt;/p&gt;
&lt;p&gt;所谓匹配，是要涵盖 整个字符串s的，而不是部分字符串。&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s 可能为空，且只包含从 a-z 的小写字母。

p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第九题】回文数</title>
    <link href="http://yoursite.com/2019/10/19/Leetcode%E3%80%90%E7%AC%AC%E4%B9%9D%E9%A2%98%E3%80%91%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/19/Leetcode【第九题】回文数/</id>
    <published>2019-10-19T08:23:43.000Z</published>
    <updated>2019-10-19T09:26:55.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-回文数"><a href="#题目-回文数" class="headerlink" title="题目 回文数"></a>题目 回文数</h1><blockquote><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>进阶:你能不将整数转为字符串来解决这个问题吗？</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>字符串解法：非负整数，反转，判断是否相等</p><p>非字符串解法：计算位数和余数，寻找对应关系</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(max(n,n/2))</p><p>空间复杂度：O(n)</p></blockquote></blockquote><p><code>pytho 除法运算符</code></p><blockquote><p>// 向下整除</p><p>% 取余</p></blockquote><hr><h4 id="代码1-字符串解法"><a href="#代码1-字符串解法" class="headerlink" title="代码1 字符串解法"></a>代码1 字符串解法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x: int) -&gt; bool:        </span><br><span class="line">        if str(x) == str(x)[::-1]:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure><h4 id="代码2-除法解法"><a href="#代码2-除法解法" class="headerlink" title="代码2 除法解法"></a>代码2 除法解法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x: int) -&gt; bool:        </span><br><span class="line">        if (x &lt; 0) or (x != 0 and x % 10 == 0):</span><br><span class="line">            return False</span><br><span class="line">        cmp_num = 0</span><br><span class="line">        while x &gt; cmp_num:</span><br><span class="line">            cmp_num = cmp_num * 10 + x % 10</span><br><span class="line">            x //= 10</span><br><span class="line">        return x == cmp_num or x == cmp_num // 10</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-回文数&quot;&gt;&lt;a href=&quot;#题目-回文数&quot; class=&quot;headerlink&quot; title=&quot;题目 回文数&quot;&gt;&lt;/a&gt;题目 回文数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。&lt;/p&gt;
&lt;p&gt;进阶:你能不将整数转为字符串来解决这个问题吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="回文数" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第八题】字符串转换整数（atoi）</title>
    <link href="http://yoursite.com/2019/10/19/leetcode%E3%80%90%E7%AC%AC%E5%85%AB%E9%A2%98%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%EF%BC%88atoi%EF%BC%89/"/>
    <id>http://yoursite.com/2019/10/19/leetcode【第八题】字符串转换整数（atoi）/</id>
    <published>2019-10-19T08:09:07.000Z</published>
    <updated>2019-10-19T08:09:38.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-字符串转换整数"><a href="#题目-字符串转换整数" class="headerlink" title="题目 字符串转换整数"></a>题目 字符串转换整数</h1><blockquote><p>请你来实现一个atoi函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为[−231, 231− 1]。如果数值超过这个范围，请返回INT_MAX (231− 1) 或INT_MIN (−231) 。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure><h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。</span><br><span class="line">因此无法执行有效的转换。</span><br></pre></td></tr></table></figure><h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>考验循环中附加条件的位置关系 ==这题比较恶心，想尝试简化流程，但很难。==</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，遍历一遍整数字符串</p><p>空间复杂度：O(n)，总长最长为整数字符串长度</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def myAtoi(self, str):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type str: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        raw_str = str</span><br><span class="line">        </span><br><span class="line">        # 可靠字符集</span><br><span class="line">        valid_set = </span><br><span class="line">        &#123;</span><br><span class="line">            &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, </span><br><span class="line">            &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;,</span><br><span class="line">            &apos;+&apos;, &apos;-&apos;, &apos; &apos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        # 数字字符集</span><br><span class="line">        num_set = </span><br><span class="line">        &#123;</span><br><span class="line">        &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, </span><br><span class="line">        &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        # 正负字符集</span><br><span class="line">        sign_set = &#123;&apos;+&apos;, &apos;-&apos;&#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        k = 0  # 当前位置</span><br><span class="line">        m = 0  # 正负计数符</span><br><span class="line">        p = 0  # 空格位置符</span><br><span class="line">        n = 0  # 正负位置符</span><br><span class="line">        i = 0  # 位数</span><br><span class="line"></span><br><span class="line">        tmp_str = &apos;&apos;</span><br><span class="line"></span><br><span class="line">        if len(raw_str) == 0:</span><br><span class="line">        # 【可能性】 空字符串</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        if raw_str[0] not in valid_set:</span><br><span class="line">        # 【可能性】 非可靠字符串</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        for s in raw_str:</span><br><span class="line">        </span><br><span class="line">            if s in sign_set:</span><br><span class="line">                if i &gt; 0:</span><br><span class="line">                    break</span><br><span class="line">                m = m + 1</span><br><span class="line">                n = k</span><br><span class="line">                # 【可能性】 字符串含超过1个正负号</span><br><span class="line">                if m &gt; 1:</span><br><span class="line">                    return 0</span><br><span class="line">                    </span><br><span class="line">            if s == &apos; &apos;:</span><br><span class="line">                if i &gt; 0:</span><br><span class="line">                    break</span><br><span class="line">                p = k</span><br><span class="line"></span><br><span class="line">            if s in num_set:</span><br><span class="line">                # 【可能性】 正负号后跟空格</span><br><span class="line">                if p &gt; n and m &gt; 0:</span><br><span class="line">                    return 0</span><br><span class="line">                i = i + 1</span><br><span class="line">                tmp_str = tmp_str + s</span><br><span class="line"></span><br><span class="line">            if s not in valid_set:</span><br><span class="line">                k = k + 1</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            k = k + 1</span><br><span class="line"></span><br><span class="line">        if i == 0:</span><br><span class="line">            return 0</span><br><span class="line">        else:</span><br><span class="line">            if m &gt; 0:</span><br><span class="line">                tmp_str = raw_str[n] + tmp_str</span><br><span class="line"></span><br><span class="line">        covert_int = int(tmp_str)</span><br><span class="line"></span><br><span class="line">        # 越界判断</span><br><span class="line">        if covert_int &gt;= 2**31 - 1:</span><br><span class="line">            return 2**31 - 1</span><br><span class="line">        if covert_int &lt;= (-2**31):</span><br><span class="line">            return (-2**31)</span><br><span class="line"></span><br><span class="line">        return covert_int</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-字符串转换整数&quot;&gt;&lt;a href=&quot;#题目-字符串转换整数&quot; class=&quot;headerlink&quot; title=&quot;题目 字符串转换整数&quot;&gt;&lt;/a&gt;题目 字符串转换整数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;请你来实现一个atoi函数，使其能将字符串转换成整数。&lt;/p&gt;
&lt;p&gt;首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。&lt;/p&gt;
&lt;p&gt;当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。&lt;/p&gt;
&lt;p&gt;该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。&lt;/p&gt;
&lt;p&gt;注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。&lt;/p&gt;
&lt;p&gt;在任何情况下，若函数不能进行有效的转换时，请返回 0。&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为[−231, 231− 1]。如果数值超过这个范围，请返回INT_MAX (231− 1) 或INT_MIN (−231) 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="编程基础" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第七题】整数反转</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%B8%83%E9%A2%98%E3%80%91%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第七题】整数反转/</id>
    <published>2019-10-16T09:44:07.000Z</published>
    <updated>2019-10-16T09:47:51.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-整数反转"><a href="#题目-整数反转" class="headerlink" title="题目 整数反转"></a>题目 整数反转</h1><blockquote><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>注意:<br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为[−231, 231− 1]。</p><p>请根据这个假设，如果反转后整数溢出那么就返回 0。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>考验对基本函数的熟悉程度</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，遍历一遍整数字符串</p><p>空间复杂度：O(n)，总长为整数字符串长度</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def reverse(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        list_str_x = list(str(abs(x)))</span><br><span class="line"></span><br><span class="line">        res = int(&apos;&apos;.join(list_str_x[::-1]))</span><br><span class="line">        if res &lt; -  2147483648 or res &gt; 2147483647 :</span><br><span class="line">            res = 0</span><br><span class="line">        return res if x &gt; 0 else - res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-整数反转&quot;&gt;&lt;a href=&quot;#题目-整数反转&quot; class=&quot;headerlink&quot; title=&quot;题目 整数反转&quot;&gt;&lt;/a&gt;题目 整数反转&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为[−231, 231− 1]。&lt;/p&gt;
&lt;p&gt;请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode【第六题】Z字形变换</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E5%85%AD%E9%A2%98%E3%80%91z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第六题】z字形变换/</id>
    <published>2019-10-16T09:42:07.000Z</published>
    <updated>2019-10-16T09:47:30.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-Z字形变换"><a href="#题目-Z字形变换" class="headerlink" title="题目 Z字形变换"></a>题目 Z字形变换</h1><blockquote><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>比如输入字符串为 “LEETCODEISHIRING”行数为 3 时，排列如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><blockquote><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>找到Z字的转折点规律是关键</p><p>标记示例字符串各字符所在行数 ==’LDREOEIIECIHNTSG’==</p><p>L E E T C O D E I S H I R I N G</p><p>1 2 3 2 1 2 3 2 1 2 3 2 1 2 3 2</p><p>L E E T C O D E I S H I R I N G</p><p>1 2 3 4 3 2 1 2 3 4 3 2 1 2 3 4</p><p>易得规律：转折点在[1,numRows]两端反复</p><p>定义一个计数器，记录当前行数与给定行数间的关系，当行数为1或等于给定行数时，取相反数</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，遍历一遍字符串</p><p>空间复杂度：O(n)，需要对应的列表存储，总长为字符串长度</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def convert(self, s, numRows):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :type numRows: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 行数小于2，直接返回</span><br><span class="line">        if numRows &lt; 2:</span><br><span class="line">            return s</span><br><span class="line">        </span><br><span class="line">        # 以字符串构建行列表</span><br><span class="line">        res = [&apos;&apos; for i in range(numRows)]</span><br><span class="line"></span><br><span class="line">        spot = - 1 # 转折点</span><br><span class="line">        n = 1 # 计数器</span><br><span class="line">        for str_ in s:</span><br><span class="line">            res[n - 1] = res[n - 1] + str_</span><br><span class="line">            if n == 1 or n == numRows:</span><br><span class="line">                spot = - spot</span><br><span class="line">            n = n + spot</span><br><span class="line"></span><br><span class="line">        return &apos;&apos;.join(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-Z字形变换&quot;&gt;&lt;a href=&quot;#题目-Z字形变换&quot; class=&quot;headerlink&quot; title=&quot;题目 Z字形变换&quot;&gt;&lt;/a&gt;题目 Z字形变换&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;br&gt;比如输入字符串为 “LEETCODEISHIRING”行数为 3 时，排列如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;L   C   I   R&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E T O E S I I G&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;E   D   H   N&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Leetcode【第五题】最长回文子串</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%BA%94%E9%A2%98%E3%80%91%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第五题】最长回文子串/</id>
    <published>2019-10-16T06:12:07.000Z</published>
    <updated>2019-10-16T06:13:02.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-最长回文子串"><a href="#题目-最长回文子串" class="headerlink" title="题目 最长回文子串"></a>题目 最长回文子串</h1><blockquote><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>在有序数组中，寻找一个索引i ，使得<br>索引左边的数小于等于索引右边的数</p><p>当两个数组的元素之和为奇数时，size 左 = size 右 + 1</p><p>当两个数组的元素之和为偶数时，size 左 = size 右</p><p>考虑边界线附近的划分</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n²)</p><p>空间复杂度：O(n²)，需要二维数对存储状态</p></blockquote></blockquote><p><code>and 和 or 的短路原则</code></p><blockquote><p>对于 and 来说：</p><p>如果第一个条件的结论为假，那么 and 前后两个条件组成的表达式计算结果一定为假，后面的条件计算机不会进行计算</p><p>对于 or 来说：</p><p>如果第一个条件的结论为真，那么 or 前后两个条件组成的表达式计算结果一定为真，后面的条件计算机不会进行计算</p></blockquote><hr><p><code>动态规划 dynamic programming</code></p><blockquote><p>1、定义 “状态”；</p><p>2、找到 “状态转移方程”。</p></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def longestPalindrome(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        size = len(s)</span><br><span class="line">        if size &lt;= 1:</span><br><span class="line">            return s</span><br><span class="line">        # 二维 dp 问题</span><br><span class="line">        dp = [[False for _ in range(size)] for _ in range(size)]</span><br><span class="line">    </span><br><span class="line">        longest_l = 1</span><br><span class="line">        res = s[0]</span><br><span class="line">    </span><br><span class="line">        # 左边界一定要比右边界小，因此右边界从 1 开始</span><br><span class="line">        for right_ in range(1, size):</span><br><span class="line">            for left_ in range(right_):</span><br><span class="line">                # 状态转移方程：如果头尾字符相等并且中间也是回文</span><br><span class="line">                if s[left_] == s[right_] and (right_ - left_ &lt;= 2 or dp[left_ + 1][right_ - 1]):</span><br><span class="line">                    # 更新状态</span><br><span class="line">                    dp[left_][right_] = True</span><br><span class="line">                    cur_len = right_ - left_ + 1</span><br><span class="line">                    if cur_len &gt; longest_l:</span><br><span class="line">                        longest_l = cur_len</span><br><span class="line">                        res = s[left_:right_ + 1]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-最长回文子串&quot;&gt;&lt;a href=&quot;#题目-最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;题目 最长回文子串&quot;&gt;&lt;/a&gt;题目 最长回文子串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="回文" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第四题】寻找两个有序数组的中位数</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E5%9B%9B%E9%A2%98%E3%80%91%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第四题】寻找两个有序数组的中位数/</id>
    <published>2019-10-16T06:10:07.000Z</published>
    <updated>2019-10-16T06:14:27.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-寻找两个有序数组的中位数"><a href="#题目-寻找两个有序数组的中位数" class="headerlink" title="题目 寻找两个有序数组的中位数"></a>题目 寻找两个有序数组的中位数</h1><blockquote><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>在有序数组中，寻找一个索引i ，使得<br>索引左边的数小于等于索引右边的数</p><p>当两个数组的元素之和为奇数时，size 左 = size 右 + 1</p><p>当两个数组的元素之和为偶数时，size 左 = size 右</p><p>考虑边界线附近的划分</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(log(min(m,n)))</p><p>查找区间为[0,m]，该区间的长度在每次循环后都会减少一半。所以，我们只需要执行 log(m) 次循环。</p><p>由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log(m))。<br>由于 m≤n，所以时间复杂度是 O(log({min}(m,n)))。</p><p>空间复杂度：O(1)，<br>只需存储几个局部变量</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def findMedianSortedArrays(A, B):</span><br><span class="line">    m, n = len(A), len(B)</span><br><span class="line">    if m &gt; n:</span><br><span class="line">        A, B, m, n = B, A, n, m</span><br><span class="line">    if n == 0:</span><br><span class="line">        raise ValueError</span><br><span class="line"></span><br><span class="line">    imin, imax, half_len = 0, m, (m + n + 1) / 2</span><br><span class="line">    while imin &lt;= imax:</span><br><span class="line">        i = (imin + imax) / 2</span><br><span class="line">        j = half_len - i</span><br><span class="line">        if i &lt; m and B[j-1] &gt; A[i]:</span><br><span class="line">            imin = i + 1</span><br><span class="line">        elif i &gt; 0 and A[i-1] &gt; B[j]:</span><br><span class="line">            imax = i - 1</span><br><span class="line">        else:</span><br><span class="line">            if i == 0: max_of_left = B[j-1]</span><br><span class="line">            elif j == 0: max_of_left = A[i-1]</span><br><span class="line">            else: max_of_left = max(A[i-1], B[j-1])</span><br><span class="line"></span><br><span class="line">            if (m + n) % 2 == 1:</span><br><span class="line">                return max_of_left</span><br><span class="line"></span><br><span class="line">            if i == m: min_of_right = B[j]</span><br><span class="line">            elif j == n: min_of_right = A[i]</span><br><span class="line">            else: min_of_right = min(A[i], B[j])</span><br><span class="line"></span><br><span class="line">            return (max_of_left + min_of_right) / 2.0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-寻找两个有序数组的中位数&quot;&gt;&lt;a href=&quot;#题目-寻找两个有序数组的中位数&quot; class=&quot;headerlink&quot; title=&quot;题目 寻找两个有序数组的中位数&quot;&gt;&lt;/a&gt;题目 寻找两个有序数组的中位数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;/p&gt;
&lt;p&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;/p&gt;
&lt;p&gt;你可以假设 nums1 和 nums2 不会同时为空。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="二分法" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第三题】无重复字符串的最长子串</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%B8%89%E9%A2%98%E3%80%91%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第三题】无重复字符串的最长子串/</id>
    <published>2019-10-16T06:09:07.000Z</published>
    <updated>2019-10-16T06:22:58.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-无重复字符串的最长子串"><a href="#题目-无重复字符串的最长子串" class="headerlink" title="题目 无重复字符串的最长子串"></a>题目 无重复字符串的最长子串</h1><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p></blockquote><a id="more"></a><hr><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是&quot;wke&quot;，所以其长度为 3。请注意，你的答案必须是 子串 的长度，&quot;pwke&quot;是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>滑动窗口是数组/字符串问题中常用的抽象概念。</p><p>窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j)向右滑动 1 个元素，则它将变为 [i+1, j+1)（左闭，右开）。</p><p>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j)（最初 j = i）中。 然后我们向右侧滑动索引 j，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n) or O(2n)</p><p>空间复杂度：O(min(m,n))，<br>滑动窗口的大小为所求子串的最大长度 k。k取决于 m,n 两者的最小值</p></blockquote></blockquote><hr><h4 id="代码-1-有添加删除动作的滑动窗口"><a href="#代码-1-有添加删除动作的滑动窗口" class="headerlink" title="代码 1 有添加删除动作的滑动窗口"></a>代码 1 有添加删除动作的滑动窗口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 缺点是真实增删数据，内存消耗严重</span><br><span class="line">class Solution(object):</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 如果字符串s为空，返回0</span><br><span class="line">        if not s:</span><br><span class="line">            return 0</span><br><span class="line">    </span><br><span class="line">        Sliding_window = []</span><br><span class="line">        max_len = 0</span><br><span class="line">        cur_len = 0</span><br><span class="line">    </span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            char_val = s[i]</span><br><span class="line">            # 如果该值不在窗口中</span><br><span class="line">            if char_val not in Sliding_window:</span><br><span class="line">                Sliding_window.append(char_val)</span><br><span class="line">                cur_len = cur_len + 1</span><br><span class="line">    </span><br><span class="line">            # 如果该值在窗口中已存在</span><br><span class="line">            else:</span><br><span class="line">                index = Sliding_window.index(char_val)</span><br><span class="line">                # 移除该位置及之前的所有字符</span><br><span class="line">                Sliding_window = Sliding_window[index+1:]</span><br><span class="line">                Sliding_window.append(char_val)</span><br><span class="line">                cur_len = len(Sliding_window)</span><br><span class="line">    </span><br><span class="line">            if cur_len &gt; max_len:</span><br><span class="line">                max_len = cur_len</span><br><span class="line">    </span><br><span class="line">        return max_len</span><br></pre></td></tr></table></figure><hr><h4 id="代码-2-模拟左右指针的滑动窗口"><a href="#代码-2-模拟左右指针的滑动窗口" class="headerlink" title="代码 2 模拟左右指针的滑动窗口"></a>代码 2 模拟左右指针的滑动窗口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 优点是不直接操作窗口</span><br><span class="line">class Solution(object):</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 如果字符串s为空，返回0</span><br><span class="line">        if not s:</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        Sliding_window = s</span><br><span class="line">        max_len = 0      # 滑动窗口数组</span><br><span class="line">        left, right = 0, 0  # 双指针</span><br><span class="line">    </span><br><span class="line">        for i, char_val in enumerate(Sliding_window):</span><br><span class="line">            # 如果该值不在窗口中</span><br><span class="line">            if char_val not in Sliding_window[left:right]:</span><br><span class="line">                right = right + 1</span><br><span class="line">            # 如果该值在窗口中已存在，移除该位置及之前的所有字符</span><br><span class="line">            else:</span><br><span class="line">                # 左指针 右指针 右移一位</span><br><span class="line">                left = left + Sliding_window[left:right].index(char_val) + 1</span><br><span class="line">                right = right + 1</span><br><span class="line">    </span><br><span class="line">            # 更新最大长度</span><br><span class="line">            max_len = max(right - left, max_len)</span><br><span class="line"></span><br><span class="line">        return max_len if max_len != 0 else len(Sliding_window)</span><br></pre></td></tr></table></figure><hr><h4 id="代码-3-哈希表"><a href="#代码-3-哈希表" class="headerlink" title="代码 3 ==哈希表=="></a>代码 3 ==哈希表==</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def lengthOfLongestSubstring(self, s):</span><br><span class="line"></span><br><span class="line">    # 可抛弃字符串的索引尾值 - 字符串索引值，该索引值以及之前的字符都属于重复字符串中的一部分，不再在计算中涉及</span><br><span class="line">    ignore_str_index_end = -1</span><br><span class="line">    dic = &#123;&#125;  # 任意字符最后出现在索引的位置 - &#123;字符: 字符索引值&#125;</span><br><span class="line">    max_len = 0  # 最长字符串长度</span><br><span class="line"></span><br><span class="line">    for i, char_val in enumerate(s):</span><br><span class="line">        # 如果字典中已经存在字符char_val，则字符char_val重复</span><br><span class="line">        # 先更新可抛弃字符串的索引尾值为字符char_val上一次的索引值</span><br><span class="line">        if char_val in dic and dic[char_val] &gt; ignore_str_index_end:</span><br><span class="line">            ignore_str_index_end = dic[char_val]</span><br><span class="line">            # 再更新字符char_val的索引值</span><br><span class="line">            dic[char_val] = i</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            # 更新字符最近的索引位置</span><br><span class="line">            dic[char_val] = i</span><br><span class="line">            # 更新最大长度</span><br><span class="line">            max_len = max(dic[char_val] - ignore_str_index_end, max_len)</span><br><span class="line"></span><br><span class="line">    return max_len</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-无重复字符串的最长子串&quot;&gt;&lt;a href=&quot;#题目-无重复字符串的最长子串&quot; class=&quot;headerlink&quot; title=&quot;题目 无重复字符串的最长子串&quot;&gt;&lt;/a&gt;题目 无重复字符串的最长子串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="滑动窗口" scheme="http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第二题】两数相加</title>
    <link href="http://yoursite.com/2019/10/16/Leetcode%E3%80%90%E7%AC%AC%E4%BA%8C%E9%A2%98%E3%80%91%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2019/10/16/Leetcode【第二题】两数相加/</id>
    <published>2019-10-16T05:51:44.000Z</published>
    <updated>2019-10-16T06:12:41.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-两数相加"><a href="#题目-两数相加" class="headerlink" title="题目 两数相加"></a>题目 两数相加</h1><blockquote><p>给出两个非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0开头。</p></blockquote><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><blockquote><p>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表l1和l2的表头开始相加。由于每位数字都应当处于0…9的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为2，并将进位carry = 1带入下一次迭代。进位carry必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(max(m,n))，<br>假设m和n分别为l1,l2的长度，数位相加，最多运算max(m,n),所以时间复杂度为 O(max(m,n))。</p><p>空间复杂度：O(max(m,n))，<br>新列表的长度最多为max(m,n)+1。</p></blockquote></blockquote><hr><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line">class ListNode(object):</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line">class Solution(object):</span><br><span class="line">    def addTwoNumbers(self, n, m):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type n: ListNode</span><br><span class="line">        :type m: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 两次循环将列表转换为数值 step 1</span><br><span class="line">        carry_bit = 1   # 进位符 carry bit</span><br><span class="line">        num_l1 = 0</span><br><span class="line">        while n:</span><br><span class="line">            num_l1 = num_l1 + n.val * carry_bit</span><br><span class="line">            carry_bit = carry_bit * 10</span><br><span class="line">            n = n.next</span><br><span class="line"></span><br><span class="line">        # 两次循环将列表转换为数值 step 2</span><br><span class="line">        carry_bit = 1</span><br><span class="line">        num_l2 = 0</span><br><span class="line">        while m:</span><br><span class="line">            num_l2 = num_l2 + m.val * carry_bit</span><br><span class="line">            carry_bit = carry_bit * 10</span><br><span class="line">            m = m.next</span><br><span class="line"></span><br><span class="line">        # 转换成字符串</span><br><span class="line">        str_num = str(num_l1 + num_l2)</span><br><span class="line">        # 倒序排列</span><br><span class="line">        str_num = str_num[::-1]</span><br><span class="line">        res = list_result = ListNode(0)</span><br><span class="line"></span><br><span class="line">        for num in str_num:</span><br><span class="line">            list_result.next = ListNode(int(num))</span><br><span class="line">            list_result = list_result.next</span><br><span class="line">        return res.next</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-两数相加&quot;&gt;&lt;a href=&quot;#题目-两数相加&quot; class=&quot;headerlink&quot; title=&quot;题目 两数相加&quot;&gt;&lt;/a&gt;题目 两数相加&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给出两个非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。&lt;/p&gt;
&lt;p&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;/p&gt;
&lt;p&gt;您可以假设除了数字 0 之外，这两个数都不会以 0开头。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="计算符号" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E7%AC%A6%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode【第一题】两数之和</title>
    <link href="http://yoursite.com/2019/10/14/Leetcode%E3%80%90%E7%AC%AC%E4%B8%80%E9%A2%98%E3%80%91%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2019/10/14/Leetcode【第一题】两数之和/</id>
    <published>2019-10-14T06:23:07.000Z</published>
    <updated>2019-10-16T06:12:32.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-两数之和"><a href="#题目-两数之和" class="headerlink" title="题目 两数之和"></a>题目 两数之和</h1><blockquote><p>给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p></blockquote><a id="more"></a><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><hr><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><blockquote><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？==哈希表==。</p><p>通过==以空间换取速度==的方式，我们可以将查找时间从 ==O(n)降低到 O(1)==。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。</p><p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！</p><blockquote><p>复杂度分析：</p><p>时间复杂度：O(n)，<br>我们把包含有 n个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。</p><p>空间复杂度：O(n)，<br>所需的额外空间取决于哈希表中存储的元素数量，该表中存储了n个元素。</p></blockquote></blockquote><hr><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def twoSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        hashmap=&#123;&#125;</span><br><span class="line">        for ind,num in enumerate(nums): # 第一次迭代创建哈希表</span><br><span class="line">            hashmap[num] = ind</span><br><span class="line">        for i,num in enumerate(nums):</span><br><span class="line">            j = hashmap.get(target - num)</span><br><span class="line">            if j is not None and i!=j:</span><br><span class="line">                return [i,j]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目-两数之和&quot;&gt;&lt;a href=&quot;#题目-两数之和&quot; class=&quot;headerlink&quot; title=&quot;题目 两数之和&quot;&gt;&lt;/a&gt;题目 两数之和&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。&lt;br&gt;你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
